/*
The sample based on oop/interfaces2.fav.

BUG: This seems to be because of the ordering of the declarations interface types can't be created or resolved:

Unhandled exception. System.NullReferenceException: Object reference not set to an instance of an object.
   at Raven.CodeAnalysis.TypeSymbolExtensionsForCodeGen.GetClrTypeInternal(ITypeSymbol typeSymbol, CodeGenerator codeGen, Boolean treatUnitAsVoid, Boolean isTopLevel) in /Users/robert/Projects/Raven/src/Raven.CodeAnalysis/TypeSymbolExtensionsForCodeGen.cs:line 50
   at Raven.CodeAnalysis.TypeSymbolExtensionsForCodeGen.<>c__DisplayClass2_0.<GetClrTypeInternal>b__0(ITypeSymbol arg) in /Users/robert/Projects/Raven/src/Raven.CodeAnalysis/TypeSymbolExtensionsForCodeGen.cs:line 41
   at System.Linq.Enumerable.ArraySelectIterator`2.Fill(ReadOnlySpan`1 source, Span`1 destination, Func`2 func)
   at System.Linq.Enumerable.ArraySelectIterator`2.ToArray()
   at Raven.CodeAnalysis.TypeSymbolExtensionsForCodeGen.GetClrTypeInternal(ITypeSymbol typeSymbol, CodeGenerator codeGen, Boolean treatUnitAsVoid, Boolean isTopLevel) in /Users/robert/Projects/Raven/src/Raven.CodeAnalysis/TypeSymbolExtensionsForCodeGen.cs:line 40
   at Raven.CodeAnalysis.TypeSymbolExtensionsForCodeGen.GetClrType(ITypeSymbol typeSymbol, CodeGenerator codeGen) in /Users/robert/Projects/Raven/src/Raven.CodeAnalysis/TypeSymbolExtensionsForCodeGen.cs:line 14
   at Raven.CodeAnalysis.CodeGen.TypeGenerator.ResolveClrType(ITypeSymbol typeSymbol) in /Users/robert/Projects/Raven/src/Raven.CodeAnalysis/CodeGen/TypeGenerator.cs:line 1301
   at Raven.CodeAnalysis.CodeGen.TypeGenerator.DefineTypeBuilder() in /Users/robert/Projects/Raven/src/Raven.CodeAnalysis/CodeGen/TypeGenerator.cs:line 240
   at Raven.CodeAnalysis.CodeGen.CodeGenerator.EnsureTypeBuilderDefined(ITypeSymbol typeSymbol, HashSet`1 visited, HashSet`1 visiting) in /Users/robert/Projects/Raven/src/Raven.CodeAnalysis/CodeGen/CodeGenerator.cs:line 1606
   at Raven.CodeAnalysis.CodeGen.CodeGenerator.DefineTypeBuilders() in /Users/robert/Projects/Raven/src/Raven.CodeAnalysis/CodeGen/CodeGenerator.cs:line 1189

   I think this is a matter of fixing the compiler passes.
   Also, make sure that similar issue is not occurring in other places.
*/

import System.*
import System.Console.*
import System.Threading.*
import System.Threading.Tasks.*

async func Main() -> Task {
    val handler: IRequestHandler<SubmitOrder, Response<decimal>> = SubmitOrderHandler()

    val items = [
        OrderItem("Item 1", 20.99m, "pc", 1),
        OrderItem("Item 2", 5.0m, "pc", 11),
        OrderItem("Item 3", 10.0m, "l", 2)
    ]

    val request = SubmitOrder(items)

    val result = await handler.Handle(request, default)
    WriteLine("Result $result")

    val str = result match {
        .Success(val value) => value.ToString(),
        .Failure(val message) => message
    }

    WriteLine("$str")
}

class SubmitOrderHandler : IRequestHandler<SubmitOrder, Response<decimal>> {

    val discountedProduct = "Item 2"
    val discountedQuantityThreshold = 10

    public async Handle(request: SubmitOrder, cancellationToken: CancellationToken) -> Task<Response<decimal>> {
        await Task.Delay(500)
        var total = .0m
        for item in request.OrderItems {
            var lineTotal = item.UnitPrice * item.Quantity
            if item is { Product: discountedProduct, Quantity: > discountedQuantityThreshold } val p {
                WriteLine("Applied 20% discount to: ${p.Product}")
                lineTotal = lineTotal * 0.8m
            }
            total += lineTotal
        }
        return .Success(total)
    }
}

union Response<T> {
    Success(value: T)
    Failure(message: string)
}

interface IRequestHandler<TRequest, TReturn> 
    where TRequest : class 
    where TReturn : new () {
 
    Handle(request: TRequest, cancellationToken: CancellationToken) -> Task<TReturn>; 
}

class SubmitOrder(orderItems: OrderItem[]) {
    public OrderItems: OrderItem[] => orderItems
}

class OrderItem(product: string, unitPrice: decimal, unit: string, quantity: int) {
    public Product: string => product

    public UnitPrice: decimal => unitPrice

    public Unit: string => unit

    public Quantity: int => quantity
}
