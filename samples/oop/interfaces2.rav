import System.*
import System.Console.*
import System.Threading.*
import System.Threading.Tasks.*

async func Main() -> Task {
    val handler: IRequestHandler<SubmitOrder, Response<decimal>> = SubmitOrderHandler()

    val items = [
        OrderItem("Item 1", 20.99m, "pc", 1),
        OrderItem("Item 2", 5.0m, "pc", 11),
        OrderItem("Item 3", 10.0m, "l", 2)
    ]

    val request = SubmitOrder(items)

    val result = await handler.Handle(request, default)
    WriteLine("Result $result")

    val str = result match {
        .Success(val value) => value.ToString(),
        .Failure(val message) => message
    }

    WriteLine("$str")
}

union Response<T> {
    Success(value: T)
    Failure(message: string)
}

interface IRequestHandler<TRequest, TReturn> 
    where TRequest : class 
    where TReturn : new () {
 
    Handle(request: TRequest, cancellationToken: CancellationToken) -> Task<TReturn>; 
}

class SubmitOrder(orderItems: OrderItem[]) {
    public OrderItems: OrderItem[] => orderItems
}

class OrderItem(product: string, unitPrice: decimal, unit: string, quantity: int) {
    public Product: string => product

    public UnitPrice: decimal => unitPrice

    public Unit: string => unit

    public Quantity: int => quantity
}

class SubmitOrderHandler : IRequestHandler<SubmitOrder, Response<decimal>> {

    val discountedProduct = "Item 2"
    val discountedQuantityThreshold = 10

    public async Handle(request: SubmitOrder, cancellationToken: CancellationToken) -> Task<Response<decimal>> {
        await Task.Delay(500)
        var total: decimal = .0m
        for item in request.OrderItems {
            var lineTotal = item.UnitPrice * item.Quantity
            if item is { Product: discountedProduct, Quantity: > discountedQuantityThreshold } p {
                WriteLine("Applied 20% discount to: ${p.Product}")
                lineTotal = lineTotal * 0.8m
            }
            total += lineTotal
        }
        return .Success(total)
    }
}