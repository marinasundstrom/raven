import System.*
import System.Console.*
import System.Collections.Generic.*

val arr = [1, 2, 3]

val cond = true

// We need to infer the union type from the cases, in a way that is pseudo-class hierarchy, 
// so they can converge both when assigned to inferred or explicitly typed targets.
// Perform joining based on the types.
// And for "arr.FirstOrError(() => DomainError.NotFound)" to alone render "Result<int, NotFound>" is not wrong, but misleading.
// We need consistency - so perhaps we should treat case types as implicitly their union type when created.

val x =
    if cond
        arr.FirstOrError(() => DomainError.NotFound())
    else
        arr.FirstOrError(() => DomainError.Unexpected(Exception()))

WriteLine(x)

/*
val x2: Result<int, DomainError> =
    if cond
        arr.FirstOrError(() => .NotFound)
    else
        arr.FirstOrError(() => .Unexpected(Exception()))

WriteLine(x2)
*/

//WriteLine(x.GetType())

union DomainError {
    NotFound
    Unexpected(exception: Exception)
}