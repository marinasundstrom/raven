import System.*
import System.Console.*
import System.Net.Http.*
import System.Threading.Tasks.*

/// Functions + Result/Option + pattern matching.
func ParseId(text: string) -> Result<int, string> {
    // `try` converts thrown exceptions into Result<T, Exception>.
    return try int.Parse(text) match {
        .Ok(val value) => .Ok(value)
        .Error(FormatException text) => .Error("Not a valid integer: '$text'")
        .Error(Exception ex) => .Error("Parse failed: ${ex.Message}")
    }
}

func FindUserName(users: User[], id: int) -> Option<string> {
    for u in users {
        if u.Id == id {
            return .Some(u.Name)
        }
    }
    return .None
}

/// Async/await + .NET interop.
async func DownloadText(url: string) -> Task<Result<string, ApiError>> {
    use http = HttpClient()

    // Interop with .NET exception model, but return as data in Raven.
    return try await http.GetStringAsync(url) match {
        .Ok(val text) => .Ok(text)
        .Error(Exception ex) => .Error(ApiError.Network(ex))
    }
}

/// Lambdas are closures (captures locals).
async func Main() -> Task {
    val logger: Logger = ConsoleLogger()

    // Event subscription (delegate interop) + lambda.
    (logger as ConsoleLogger)?.Logged += (msg: string) => {
        // expression block
        val stamp = DateTime.UtcNow
        WriteLine("  [logged at $stamp]")
    }

    logger.Log("== Raven intro tour ==")

    // Arrays + collection expression + spread.
    val baseUsers = [
        User(1, "Ada", "ada@example.com"),
        User(2, "Bo", null), // nullability is on by default (`string?`)
    ]
    val moreUsers = [User(3, "Cy", "cy@example.com")]
    val users: User[] = [..baseUsers, ..moreUsers] // target-typed to array

    logger.Log("Users:")
    for u in users {
        logger.Log("  " + u.Display())
    }

    // Nullability + interop example:
    // Prefer Option in Raven code, but sometimes you need `T?` for .NET APIs.
    val maybeName: Option<string> = .Some("Raven")
    val nameForDotNet: string? = maybeName // implicit Option<T> -> T?

    // A small local function (hoisted), and local funcs arenâ€™t closures.
    func decorate(s: string) -> string => ">> $s <<"

    logger.Log(decorate("Option -> nullable interop: " + (nameForDotNet ?? "(null)")))

    // Result/Option + pattern matching.
    val input = "2"
    val id = ParseId(input) match {
        .Ok(val value) => value
        .Error(val err) => {
            logger.Log("Bad input: $err")
            -1
        }
    }

    val label = FindUserName(users, id) match {
        .Some(val n) => "Found user name: $n"
        .None => "No user with id $id"
    }
    logger.Log(label)

    // Pattern matching over union, including typed catch patterns.
    val url = "https://example.com"
    val downloaded = await DownloadText(url)

    val summary = downloaded match {
        .Ok(val text) => "Downloaded ${text.Length} chars from $url"
        .Error(.NotFound(val missingId)) => "Not found: $missingId"
        .Error(.Invalid(val message)) => "Invalid: $message"
        .Error(.Network(Exception ex)) => "Network error: ${ex.Message}"
        .Error(_) => "None"
    }

    logger.Log(summary)
    logger.Log("== Done ==")
}

/// A small OO model (class + properties + method).
record class User(Id: int, Name: string, Email: string?) {
    public Display() -> string => "$Id: $Name <${Email ?? "(no email)"}>"
}

/// A user-defined union (explicit modeling).
union ApiError {
    NotFound(id: int)
    Invalid(message: string)
    Network(ex: Exception)
}

/// OO: interface + class + event + method
interface Logger {
    Log(message: string)
}

class ConsoleLogger : Logger {
    public event Logged: Action<string>?

    public Log(message: string) -> () {
        WriteLine(message)
        Logged?.Invoke(message) // nullable interop style (event can be null)
    }
}