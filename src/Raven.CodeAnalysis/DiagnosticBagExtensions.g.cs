// <auto-generated />
// This file was generated by tools/DiagnosticsGenerator.

namespace Raven.CodeAnalysis;

public static partial class DiagnosticBagExtensions
{
    public static void ReportCannotApplyIndexingWithToAnExpressionOfType(this DiagnosticBag diagnostics, object? typeName, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.CannotApplyIndexingWithToAnExpressionOfType, location, typeName));

    public static void ReportOperatorCannotBeAppliedToOperandOfType(this DiagnosticBag diagnostics, object? operatorToken, object? operandType, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.OperatorCannotBeAppliedToOperandOfType, location, operatorToken, operandType));

    public static void ReportOperatorCannotBeAppliedToOperandsOfTypes(this DiagnosticBag diagnostics, object? operatorToken, object? operandType1, object? operandType2, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.OperatorCannotBeAppliedToOperandsOfTypes, location, operatorToken, operandType1, operandType2));

    public static void ReportThisValueIsNotMutable(this DiagnosticBag diagnostics, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.ThisValueIsNotMutable, location));

    public static void ReportInvalidInvocation(this DiagnosticBag diagnostics, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.InvalidInvocation, location));

    public static void ReportTheNameDoesNotExistInTheCurrentContext(this DiagnosticBag diagnostics, object? name, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.TheNameDoesNotExistInTheCurrentContext, location, name));

    public static void ReportTypeAlreadyDefinesMember(this DiagnosticBag diagnostics, object? typeName, object? memberName, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.TypeAlreadyDefinesMember, location, typeName, memberName));

    public static void ReportFunctionAlreadyDefined(this DiagnosticBag diagnostics, object? name, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.FunctionAlreadyDefined, location, name));

    public static void ReportMemberDoesNotContainDefinition(this DiagnosticBag diagnostics, object? container, object? member, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.MemberDoesNotContainDefinition, location, container, member));

    public static void ReportVariableUsedLikeAType(this DiagnosticBag diagnostics, object? name, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.VariableUsedLikeAType, location, name));

    public static void ReportCallIsAmbiguous(this DiagnosticBag diagnostics, object? method1, object? method2, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.CallIsAmbiguous, location, method1, method2));

    public static void ReportLeftOfAssignmentMustBeAVariablePropertyOrIndexer(this DiagnosticBag diagnostics, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.LeftOfAssignmentMustBeAVariablePropertyOrIndexer, location));

    public static void ReportMethodNameExpected(this DiagnosticBag diagnostics, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.MethodNameExpected, location));

    public static void ReportUseOfUnassignedVariable(this DiagnosticBag diagnostics, object? name, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.UseOfUnassignedVariable, location, name));

    public static void ReportLocalVariableMustBeInitialized(this DiagnosticBag diagnostics, object? name, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.LocalVariableMustBeInitialized, location, name));

    public static void ReportVariableAlreadyDefined(this DiagnosticBag diagnostics, object? name, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.VariableAlreadyDefined, location, name));

    public static void ReportVariableShadowsOuterScope(this DiagnosticBag diagnostics, object? name, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.VariableShadowsOuterScope, location, name));

    public static void ReportReadOnlyFieldCannotBeAssignedTo(this DiagnosticBag diagnostics, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.ReadOnlyFieldCannotBeAssignedTo, location));

    public static void ReportPropertyOrIndexerCannotBeAssignedIsReadOnly(this DiagnosticBag diagnostics, object? name, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.PropertyOrIndexerCannotBeAssignedIsReadOnly, location, name));

    public static void ReportTypeOrNamespaceNameDoesNotExistInTheNamespace(this DiagnosticBag diagnostics, object? typeOrNs, object? container, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.TypeOrNamespaceNameDoesNotExistInTheNamespace, location, typeOrNs, container));

    public static void ReportTypeExpectedWithoutWildcard(this DiagnosticBag diagnostics, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.TypeExpectedWithoutWildcard, location));

    public static void ReportUnassignedOutParameter(this DiagnosticBag diagnostics, object? parameterName, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.UnassignedOutParameter, location, parameterName));

    public static void ReportTypeRequiresTypeArguments(this DiagnosticBag diagnostics, object? name, object? arity, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.TypeRequiresTypeArguments, location, name, arity));

    public static void ReportCannotInheritFromSealedType(this DiagnosticBag diagnostics, object? typeName, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.CannotInheritFromSealedType, location, typeName));

    public static void ReportOverrideMemberNotFound(this DiagnosticBag diagnostics, object? memberName, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.OverrideMemberNotFound, location, memberName));

    public static void ReportVirtualMemberInSealedType(this DiagnosticBag diagnostics, object? memberName, object? typeName, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.VirtualMemberInSealedType, location, memberName, typeName));

    public static void ReportSealedMemberMustOverride(this DiagnosticBag diagnostics, object? memberName, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.SealedMemberMustOverride, location, memberName));

    public static void ReportCannotOverrideSealedMember(this DiagnosticBag diagnostics, object? memberName, object? overriddenMemberName, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.CannotOverrideSealedMember, location, memberName, overriddenMemberName));

    public static void ReportStaticMemberCannotBeVirtualOrOverride(this DiagnosticBag diagnostics, object? memberName, object? modifier, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.StaticMemberCannotBeVirtualOrOverride, location, memberName, modifier));

    public static void ReportConstructorInitializerNotAllowedOnStaticConstructor(this DiagnosticBag diagnostics, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.ConstructorInitializerNotAllowedOnStaticConstructor, location));

    public static void ReportExplicitInterfaceSpecifierMustBeInterface(this DiagnosticBag diagnostics, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.ExplicitInterfaceSpecifierMustBeInterface, location));

    public static void ReportContainingTypeDoesNotImplementInterface(this DiagnosticBag diagnostics, object? typeName, object? interfaceName, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.ContainingTypeDoesNotImplementInterface, location, typeName, interfaceName));

    public static void ReportExplicitInterfaceMemberNotFound(this DiagnosticBag diagnostics, object? interfaceName, object? memberName, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.ExplicitInterfaceMemberNotFound, location, interfaceName, memberName));

    public static void ReportNullableTypeInUnion(this DiagnosticBag diagnostics, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.NullableTypeInUnion, location));

    public static void ReportTypeNameDoesNotExistInType(this DiagnosticBag diagnostics, object? name, object? container, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.TypeNameDoesNotExistInType, location, name, container));

    public static void ReportCannotAssignVoidToAnImplicitlyTypedVariable(this DiagnosticBag diagnostics, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.CannotAssignVoidToAnImplicitlyTypedVariable, location));

    public static void ReportExpressionExpected(this DiagnosticBag diagnostics, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.ExpressionExpected, location));

    public static void ReportIdentifierExpected(this DiagnosticBag diagnostics, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.IdentifierExpected, location));

    public static void ReportSemicolonExpected(this DiagnosticBag diagnostics, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.SemicolonExpected, location));

    public static void ReportCharacterExpected(this DiagnosticBag diagnostics, object? character, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.CharacterExpected, location, character));

    public static void ReportDuplicateModifier(this DiagnosticBag diagnostics, object? modifier, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.DuplicateModifier, location, modifier));

    public static void ReportImportDirectiveOutOfOrder(this DiagnosticBag diagnostics, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.ImportDirectiveOutOfOrder, location));

    public static void ReportAliasDirectiveOutOfOrder(this DiagnosticBag diagnostics, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.AliasDirectiveOutOfOrder, location));

    public static void ReportFieldDeclarationRequiresLetOrVar(this DiagnosticBag diagnostics, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.FieldDeclarationRequiresLetOrVar, location));

    public static void ReportUnrecognizedEscapeSequence(this DiagnosticBag diagnostics, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.UnrecognizedEscapeSequence, location));

    public static void ReportNewlineInConstant(this DiagnosticBag diagnostics, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.NewlineInConstant, location));

    public static void ReportFileScopedCodeOutOfOrder(this DiagnosticBag diagnostics, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.FileScopedCodeOutOfOrder, location));

    public static void ReportFileScopedCodeRequiresConsole(this DiagnosticBag diagnostics, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.FileScopedCodeRequiresConsole, location));

    public static void ReportFileScopedCodeMultipleFiles(this DiagnosticBag diagnostics, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.FileScopedCodeMultipleFiles, location));

    public static void ReportConsoleApplicationRequiresEntryPoint(this DiagnosticBag diagnostics, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.ConsoleApplicationRequiresEntryPoint, location));

    public static void ReportNoOverloadForMethod(this DiagnosticBag diagnostics, object? method, object? count, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.NoOverloadForMethod, location, method, count));

    public static void ReportCannotConvertFromTypeToType(this DiagnosticBag diagnostics, object? fromType, object? toType, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.CannotConvertFromTypeToType, location, fromType, toType));

    public static void ReportCannotAssignFromTypeToType(this DiagnosticBag diagnostics, object? fromType, object? toType, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.CannotAssignFromTypeToType, location, fromType, toType));

    public static void ReportInvalidExpressionTerm(this DiagnosticBag diagnostics, object? tokenText, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.InvalidExpressionTerm, location, tokenText));

    public static void ReportReturnStatementInExpression(this DiagnosticBag diagnostics, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.ReturnStatementInExpression, location));

    public static void ReportIfExpressionRequiresElse(this DiagnosticBag diagnostics, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.IfExpressionRequiresElse, location));

    public static void ReportNonInvocableMember(this DiagnosticBag diagnostics, object? memberName, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.NonInvocableMember, location, memberName));

    public static void ReportNumericLiteralOutOfRange(this DiagnosticBag diagnostics, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.NumericLiteralOutOfRange, location));

    public static void ReportUnterminatedCharacterLiteral(this DiagnosticBag diagnostics, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.UnterminatedCharacterLiteral, location));

    public static void ReportInvalidEscapeSequence(this DiagnosticBag diagnostics, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.InvalidEscapeSequence, location));

    public static void ReportMemberAccessRequiresTargetType(this DiagnosticBag diagnostics, object? memberName, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.MemberAccessRequiresTargetType, location, memberName));

    public static void ReportInvalidAliasType(this DiagnosticBag diagnostics, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.InvalidAliasType, location));

    public static void ReportInvalidImportTarget(this DiagnosticBag diagnostics, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.InvalidImportTarget, location));

    public static void ReportSpreadSourceMustBeEnumerable(this DiagnosticBag diagnostics, object? typeName, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.SpreadSourceMustBeEnumerable, location, typeName));

    public static void ReportMatchExpressionNotExhaustive(this DiagnosticBag diagnostics, object? missingType, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.MatchExpressionNotExhaustive, location, missingType));

    public static void ReportMatchExpressionArmUnreachable(this DiagnosticBag diagnostics, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.MatchExpressionArmUnreachable, location));

    public static void ReportMatchExpressionArmPatternInvalid(this DiagnosticBag diagnostics, object? patternType, object? scrutineeType, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.MatchExpressionArmPatternInvalid, location, patternType, scrutineeType));

    public static void ReportLambdaParameterTypeCannotBeInferred(this DiagnosticBag diagnostics, object? parameterName, Location location)
        => diagnostics.Report(Diagnostic.Create(CompilerDiagnostics.LambdaParameterTypeCannotBeInferred, location, parameterName));

}
