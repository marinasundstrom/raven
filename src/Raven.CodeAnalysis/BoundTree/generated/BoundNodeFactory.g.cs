// <auto-generated />
#nullable enable
using System;
using System.Collections.Immutable;

namespace Raven.CodeAnalysis;

internal sealed partial class BoundNodeFactory
{
    public BoundNodeFactory(Compilation compilation)
    {
        Compilation = compilation ?? throw new ArgumentNullException(nameof(compilation));
    }

    public Compilation Compilation { get; }

    public BoundAddressOfExpression CreateAddressOfExpression(ISymbol? symbol, ITypeSymbol valueType, BoundExpression? receiver = null, BoundExpression? storage = null)
    {
        return new BoundAddressOfExpression(symbol, valueType, receiver, storage);
    }

    public BoundAndPattern CreateAndPattern(BoundPattern left, BoundPattern right)
    {
        return new BoundAndPattern(left, right);
    }

    public BoundArrayAccessExpression CreateArrayAccessExpression(BoundExpression receiver, IEnumerable<BoundExpression> indices, ITypeSymbol elementType)
    {
        return new BoundArrayAccessExpression(receiver, indices, elementType);
    }

    public BoundArrayAssignmentExpression CreateArrayAssignmentExpression(BoundArrayAccessExpression left, BoundExpression right)
    {
        return new BoundArrayAssignmentExpression(left, right, Compilation.UnitTypeSymbol);
    }

    public BoundAsExpression CreateAsExpression(BoundExpression expression, ITypeSymbol type, Conversion conversion)
    {
        return new BoundAsExpression(expression, type, conversion);
    }

    public BoundAssignmentStatement CreateAssignmentStatement(BoundAssignmentExpression expression)
    {
        return new BoundAssignmentStatement(expression);
    }

    public BoundAwaitExpression CreateAwaitExpression(BoundExpression expression, ITypeSymbol resultType, ITypeSymbol awaiterType, IMethodSymbol getAwaiterMethod, IMethodSymbol getResultMethod, IPropertySymbol isCompletedProperty)
    {
        return new BoundAwaitExpression(expression, resultType, awaiterType, getAwaiterMethod, getResultMethod, isCompletedProperty);
    }

    public BoundBinaryExpression CreateBinaryExpression(BoundExpression left, BoundBinaryOperator @operator, BoundExpression right)
    {
        return new BoundBinaryExpression(left, @operator, right);
    }

    public BoundBlockExpression CreateBlockExpression(IEnumerable<BoundStatement> statements, ImmutableArray<ILocalSymbol> localsToDispose = default)
    {
        return new BoundBlockExpression(statements, Compilation.UnitTypeSymbol, localsToDispose);
    }

    public BoundBlockStatement CreateBlockStatement(IEnumerable<BoundStatement> statements, ImmutableArray<ILocalSymbol> localsToDispose = default)
    {
        return new BoundBlockStatement(statements, localsToDispose);
    }

    public BoundBreakStatement CreateBreakStatement()
    {
        return new BoundBreakStatement();
    }

    public BoundByRefAssignmentExpression CreateByRefAssignmentExpression(BoundExpression reference, ITypeSymbol elementType, BoundExpression right)
    {
        return new BoundByRefAssignmentExpression(reference, elementType, right, Compilation.UnitTypeSymbol);
    }

    public BoundCastExpression CreateCastExpression(BoundExpression expression, ITypeSymbol type, Conversion conversion)
    {
        return new BoundCastExpression(expression, type, conversion);
    }

    public BoundCatchClause CreateCatchClause(ITypeSymbol exceptionType, ILocalSymbol? local, BoundBlockStatement block)
    {
        return new BoundCatchClause(exceptionType, local, block);
    }

    public BoundCollectionExpression CreateCollectionExpression(ITypeSymbol type, IEnumerable<BoundExpression> elements, ISymbol? collectionSymbol = null, BoundExpressionReason reason = BoundExpressionReason.None)
    {
        return new BoundCollectionExpression(type, elements, collectionSymbol, reason);
    }

    public BoundConditionalAccessExpression CreateConditionalAccessExpression(BoundExpression receiver, BoundExpression whenNotNull, ITypeSymbol type)
    {
        return new BoundConditionalAccessExpression(receiver, whenNotNull, type);
    }

    public BoundConditionalGotoStatement CreateConditionalGotoStatement(ILabelSymbol target, BoundExpression condition, bool jumpIfTrue)
    {
        return new BoundConditionalGotoStatement(target, condition, jumpIfTrue);
    }

    public BoundContinueStatement CreateContinueStatement()
    {
        return new BoundContinueStatement();
    }

    public BoundDeclarationPattern CreateDeclarationPattern(ITypeSymbol declaredType, BoundDesignator designator, BoundExpressionReason reason = BoundExpressionReason.None)
    {
        return new BoundDeclarationPattern(declaredType, designator, reason);
    }

    public BoundDelegateCreationExpression CreateDelegateCreationExpression(BoundMethodGroupExpression methodGroup, ITypeSymbol delegateType)
    {
        return new BoundDelegateCreationExpression(methodGroup, delegateType);
    }

    public BoundEmptyCollectionExpression CreateEmptyCollectionExpression(ITypeSymbol? type = null, BoundExpressionReason reason = BoundExpressionReason.None)
    {
        return new BoundEmptyCollectionExpression(type, reason);
    }

    public BoundErrorExpression CreateErrorExpression(ITypeSymbol type, ISymbol? symbol = null, BoundExpressionReason reason = BoundExpressionReason.None)
    {
        return new BoundErrorExpression(type, symbol, reason);
    }

    public BoundExpressionStatement CreateExpressionStatement(BoundExpression expression)
    {
        return new BoundExpressionStatement(expression);
    }

    public BoundFieldAccess CreateFieldAccess(IFieldSymbol field, BoundExpressionReason reason = BoundExpressionReason.None)
    {
        return new BoundFieldAccess(field, reason);
    }

    public BoundFieldAssignmentExpression CreateFieldAssignmentExpression(BoundExpression? receiver, IFieldSymbol field, BoundExpression right, bool requiresReceiverAddress = false)
    {
        return new BoundFieldAssignmentExpression(receiver, field, right, Compilation.UnitTypeSymbol, requiresReceiverAddress);
    }

    public BoundForStatement CreateForStatement(ILocalSymbol? local, ForIterationInfo iteration, BoundExpression collection, BoundStatement body)
    {
        return new BoundForStatement(local, iteration, collection, body);
    }

    public BoundFunctionStatement CreateFunctionStatement(IMethodSymbol method)
    {
        return new BoundFunctionStatement(method);
    }

    public BoundGotoStatement CreateGotoStatement(ILabelSymbol target, bool isBackward = false)
    {
        return new BoundGotoStatement(target, isBackward);
    }

    public BoundIfExpression CreateIfExpression(BoundExpression condition, BoundExpression thenBranch, BoundExpression? elseBranch = null)
    {
        return new BoundIfExpression(condition, thenBranch, elseBranch);
    }

    public BoundIfStatement CreateIfStatement(BoundExpression condition, BoundStatement thenNode, BoundStatement? elseNode = null)
    {
        return new BoundIfStatement(condition, thenNode, elseNode);
    }

    public BoundIndexerAccessExpression CreateIndexerAccessExpression(BoundExpression receiver, IEnumerable<BoundExpression> arguments, IPropertySymbol indexer)
    {
        return new BoundIndexerAccessExpression(receiver, arguments, indexer);
    }

    public BoundIndexerAssignmentExpression CreateIndexerAssignmentExpression(BoundIndexerAccessExpression left, BoundExpression right)
    {
        return new BoundIndexerAssignmentExpression(left, right, Compilation.UnitTypeSymbol);
    }

    public BoundInvocationExpression CreateInvocationExpression(IMethodSymbol method, IEnumerable<BoundExpression> arguments, BoundExpression? receiver = null, BoundExpression? extensionReceiver = null, bool requiresReceiverAddress = false)
    {
        return new BoundInvocationExpression(method, arguments, receiver, extensionReceiver, requiresReceiverAddress);
    }

    public BoundIsPatternExpression CreateIsPatternExpression(BoundExpression expression, BoundPattern pattern, ITypeSymbol booleanType, BoundExpressionReason reason = BoundExpressionReason.None)
    {
        return new BoundIsPatternExpression(expression, pattern, booleanType, reason);
    }

    public BoundLabeledStatement CreateLabeledStatement(ILabelSymbol label, BoundStatement statement)
    {
        return new BoundLabeledStatement(label, statement);
    }

    public BoundLambdaExpression CreateLambdaExpression(IEnumerable<IParameterSymbol> parameters, ITypeSymbol returnType, BoundExpression body, ISymbol symbol, ITypeSymbol delegateType, IEnumerable<ISymbol> capturedVariables, ImmutableArray<INamedTypeSymbol> candidateDelegates)
    {
        return new BoundLambdaExpression(parameters, returnType, body, symbol, delegateType, capturedVariables, candidateDelegates);
    }

    public BoundLiteralExpression CreateLiteralExpression(BoundLiteralExpressionKind kind, object value, ITypeSymbol type, ITypeSymbol? convertedType = null)
    {
        return new BoundLiteralExpression(kind, value, type, convertedType);
    }

    public BoundLocalAccess CreateLocalAccess(ILocalSymbol local, BoundExpressionReason reason = BoundExpressionReason.None)
    {
        return new BoundLocalAccess(local, reason);
    }

    public BoundLocalAssignmentExpression CreateLocalAssignmentExpression(ILocalSymbol local, BoundExpression right)
    {
        return new BoundLocalAssignmentExpression(local, right, Compilation.UnitTypeSymbol);
    }

    public BoundLocalDeclarationStatement CreateLocalDeclarationStatement(IEnumerable<BoundVariableDeclarator> declarators, bool isUsing = false)
    {
        return new BoundLocalDeclarationStatement(declarators, isUsing);
    }

    public BoundMatchExpression CreateMatchExpression(BoundExpression expression, ImmutableArray<BoundMatchArm> arms, ITypeSymbol type)
    {
        return new BoundMatchExpression(expression, arms, type);
    }

    public BoundMemberAccessExpression CreateMemberAccessExpression(BoundExpression? receiver, ISymbol member, BoundExpressionReason reason = BoundExpressionReason.None)
    {
        return new BoundMemberAccessExpression(receiver, member, reason);
    }

    public BoundMemberAssignmentExpression CreateMemberAssignmentExpression(ISymbol member, BoundExpression receiver, BoundExpression right)
    {
        return new BoundMemberAssignmentExpression(member, receiver, right, Compilation.UnitTypeSymbol);
    }

    public BoundMethodGroupExpression CreateMethodGroupExpression(BoundExpression? receiver, ImmutableArray<IMethodSymbol> methods, ITypeSymbol methodGroupType, Func<ITypeSymbol?>? delegateTypeFactory = null, IMethodSymbol? selectedMethod = null, BoundExpressionReason reason = BoundExpressionReason.None)
    {
        return new BoundMethodGroupExpression(receiver, methods, methodGroupType, delegateTypeFactory, selectedMethod, reason);
    }

    public BoundNamespaceExpression CreateNamespaceExpression(INamespaceSymbol @namespace)
    {
        return new BoundNamespaceExpression(@namespace);
    }

    public BoundNotPattern CreateNotPattern(BoundPattern pattern)
    {
        return new BoundNotPattern(pattern);
    }

    public BoundObjectCreationExpression CreateObjectCreationExpression(IMethodSymbol constructor, IEnumerable<BoundExpression> arguments, BoundExpression? receiver = null)
    {
        return new BoundObjectCreationExpression(constructor, arguments, receiver);
    }

    public BoundOrPattern CreateOrPattern(BoundPattern left, BoundPattern right)
    {
        return new BoundOrPattern(left, right);
    }

    public BoundParameterAccess CreateParameterAccess(IParameterSymbol parameter, BoundExpressionReason reason = BoundExpressionReason.None)
    {
        return new BoundParameterAccess(parameter, reason);
    }

    public BoundParameterAssignmentExpression CreateParameterAssignmentExpression(IParameterSymbol parameter, BoundExpression right)
    {
        return new BoundParameterAssignmentExpression(parameter, right, Compilation.UnitTypeSymbol);
    }

    public BoundParenthesizedExpression CreateParenthesizedExpression(BoundExpression expression)
    {
        return new BoundParenthesizedExpression(expression);
    }

    public BoundPatternAssignmentExpression CreatePatternAssignmentExpression(ITypeSymbol type, BoundPattern pattern, BoundExpression right)
    {
        return new BoundPatternAssignmentExpression(type, pattern, right, Compilation.UnitTypeSymbol);
    }

    public BoundPropertyAccess CreatePropertyAccess(IPropertySymbol property, BoundExpressionReason reason = BoundExpressionReason.None)
    {
        return new BoundPropertyAccess(property, reason);
    }

    public BoundPropertyAssignmentExpression CreatePropertyAssignmentExpression(BoundExpression? receiver, IPropertySymbol property, BoundExpression right)
    {
        return new BoundPropertyAssignmentExpression(receiver, property, right, Compilation.UnitTypeSymbol);
    }

    public BoundReturnStatement CreateReturnStatement(BoundExpression? expression)
    {
        return new BoundReturnStatement(expression);
    }

    public BoundSelfExpression CreateSelfExpression(ITypeSymbol type, BoundExpressionReason reason = BoundExpressionReason.None)
    {
        return new BoundSelfExpression(type, reason);
    }

    public BoundSingleVariableDesignator CreateSingleVariableDesignator(ILocalSymbol local, BoundExpressionReason reason = BoundExpressionReason.None)
    {
        return new BoundSingleVariableDesignator(local, reason);
    }

    public BoundSpreadElement CreateSpreadElement(BoundExpression expression)
    {
        return new BoundSpreadElement(expression);
    }

    public BoundThrowStatement CreateThrowStatement(BoundExpression expression)
    {
        return new BoundThrowStatement(expression);
    }

    public BoundTryExpression CreateTryExpression(BoundExpression expression, ITypeSymbol exceptionType, ITypeSymbol type)
    {
        return new BoundTryExpression(expression, exceptionType, type);
    }

    public BoundTryStatement CreateTryStatement(BoundBlockStatement tryBlock, ImmutableArray<BoundCatchClause> catchClauses, BoundBlockStatement? finallyBlock)
    {
        return new BoundTryStatement(tryBlock, catchClauses, finallyBlock);
    }

    public BoundTupleExpression CreateTupleExpression(IEnumerable<BoundExpression> elements, ITypeSymbol type)
    {
        return new BoundTupleExpression(elements, type);
    }

    public BoundTypeExpression CreateTypeExpression(ITypeSymbol typeSymbol)
    {
        return new BoundTypeExpression(typeSymbol);
    }

    public BoundTypeOfExpression CreateTypeOfExpression(ITypeSymbol operandType, ITypeSymbol systemType)
    {
        return new BoundTypeOfExpression(operandType, systemType);
    }

    public BoundUnaryExpression CreateUnaryExpression(BoundUnaryOperator @operator, BoundExpression operand)
    {
        return new BoundUnaryExpression(@operator, operand);
    }

    public BoundUnitExpression CreateUnitExpression(BoundExpressionReason reason = BoundExpressionReason.None)
    {
        return new BoundUnitExpression(Compilation.UnitTypeSymbol, reason);
    }

    public BoundVariableDeclarator CreateVariableDeclarator(ILocalSymbol local, BoundExpression? initializer)
    {
        return new BoundVariableDeclarator(local, initializer);
    }

    public BoundVariableExpression CreateVariableExpression(ILocalSymbol variable)
    {
        return new BoundVariableExpression(variable);
    }

    public BoundWhileStatement CreateWhileStatement(BoundExpression condition, BoundStatement body)
    {
        return new BoundWhileStatement(condition, body);
    }

    public BoundYieldBreakStatement CreateYieldBreakStatement(ITypeSymbol elementType, IteratorMethodKind iteratorKind)
    {
        return new BoundYieldBreakStatement(elementType, iteratorKind);
    }

    public BoundYieldReturnStatement CreateYieldReturnStatement(BoundExpression expression, ITypeSymbol elementType, IteratorMethodKind iteratorKind)
    {
        return new BoundYieldReturnStatement(expression, elementType, iteratorKind);
    }

}
