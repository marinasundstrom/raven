namespace System.Linq

import System.*
import System.Linq.*
import System.Collections.Generic.*

public extension EnumerableOption<T> for IEnumerable<T> {

    // -------------------------
    // First
    // -------------------------

    public FirstOrNone() -> Option<T> {
        val values = self.Take(1).ToList()
        if values.Count == 1 {
            return .Some(values[0])
        }
        return .None
    }

    public FirstOrNone(predicate: T -> bool) -> Option<T> {
        val values = self.Where(predicate).Take(1).ToList()
        if values.Count == 1 {
            return .Some(values[0])
        }
        return .None
    }

    public FirstOrError<E>(errorFactory: () -> E) -> Result<T, E> {
        val values = self.Take(1).ToList()
        if values.Count == 1 {
            return .Ok(values[0])
        }
        return .Error(errorFactory())
    }

    public FirstOrError<E>(predicate: T -> bool, errorFactory: () -> E) -> Result<T, E> {
        val values = self.Where(predicate).Take(1).ToList()
        if values.Count == 1 {
            return .Ok(values[0])
        }
        return .Error(errorFactory())
    }

    // -------------------------
    // Last
    // -------------------------

    public LastOrNone() -> Option<T> {
        val values = self.ToList()
        if values.Count == 0 {
            return .None
        }
        return .Some(values[values.Count - 1])
    }

    public LastOrNone(predicate: T -> bool) -> Option<T> {
        val values = self.Where(predicate).ToList()
        if values.Count == 0 {
            return .None
        }
        return .Some(values[values.Count - 1])
    }

    public LastOrError<E>(errorFactory: () -> E) -> Result<T, E> {
        val values = self.ToList()
        if values.Count == 0 {
            return .Error(errorFactory())
        }
        return .Ok(values[values.Count - 1])
    }

    public LastOrError<E>(predicate: T -> bool, errorFactory: () -> E) -> Result<T, E> {
        val values = self.Where(predicate).ToList()
        if values.Count == 0 {
            return .Error(errorFactory())
        }
        return .Ok(values[values.Count - 1])
    }

    // -------------------------
    // Single
    // -------------------------

    public SingleOrNone() -> Option<T> {
        val values = self.Take(2).ToList()
        if values.Count == 1 {
            return .Some(values[0])
        }
        return .None
    }

    public SingleOrNone(predicate: T -> bool) -> Option<T> {
        val values = self.Where(predicate).Take(2).ToList()
        if values.Count == 1 {
            return .Some(values[0])
        }
        return .None
    }

    public SingleOrError<E>(errorFactory: () -> E) -> Result<T, E> {
        val values = self.Take(2).ToList()
        if values.Count == 1 {
            return .Ok(values[0])
        }
        return .Error(errorFactory())
    }

    public SingleOrError<E>(predicate: T -> bool, errorFactory: () -> E) -> Result<T, E> {
        val values = self.Where(predicate).Take(2).ToList()
        if values.Count == 1 {
            return .Ok(values[0])
        }
        return .Error(errorFactory())
    }

    public SingleOrError<E>(errorIfNone: () -> E, errorIfMany: () -> E) -> Result<T, E> {
        val values = self.Take(2).ToList()
        if values.Count == 1 {
            return .Ok(values[0])
        }
        if values.Count == 0 {
            return .Error(errorIfNone())
        }
        return .Error(errorIfMany())
    }

    public SingleOrError<E>(predicate: T -> bool, errorIfNone: () -> E, errorIfMany: () -> E) -> Result<T, E> {
        val values = self.Where(predicate).Take(2).ToList()
        if values.Count == 1 {
            return .Ok(values[0])
        }
        if values.Count == 0 {
            return .Error(errorIfNone())
        }
        return .Error(errorIfMany())
    }

    // -------------------------
    // ElementAt
    // -------------------------

    public ElementAtOrNone(index: int) -> Option<T> {
        if index < 0 {
            return .None
        }

        val values = self.Skip(index).Take(1).ToList()
        if values.Count == 1 {
            return .Some(values[0])
        }

        return .None
    }

    public ElementAtOrError<E>(index: int, errorFactory: () -> E) -> Result<T, E> {
        val opt = self.ElementAtOrNone(index)
        return opt match {
            .Some(val v) => .Ok(v)
            .None => .Error(errorFactory())
        }
    }
}
