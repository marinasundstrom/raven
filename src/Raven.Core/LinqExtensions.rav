namespace System.Linq

import System.*
import System.Linq.*
import System.Collections.Generic.*

public extension EnumerableOption<T> for IEnumerable<T> {

    // -------------------------
    // First
    // -------------------------

    // Captures the first element, or none. May throw.
    // .Some(x)   => first element
    // .None      => no elements
    public FirstOrNone() -> Option<T> {
        val values = self.Take(1).ToList()
        if values.Count == 1 {
            return .Some(values[0])
        }
        .None
    }

    // Captures the first element on predicate, or none. May throw.
    // .Some(x)   => first element
    // .None      => no elements
    public FirstOrNone(predicate: T -> bool) -> Option<T> {
        val values = self.Where(predicate).Take(1).ToList()
        if values.Count == 1 {
            return .Some(values[0])
        }
        .None
    }

    public FirstOrError<E>(errorFactory: () -> E) -> Result<T, E> {
        val values = self.Take(1).ToList()
        if values.Count == 1 {
            return .Ok(values[0])
        }
        .Error(errorFactory())
    }

    public FirstOrError<E>(predicate: T -> bool, errorFactory: () -> E) -> Result<T, E> {
        val values = self.Where(predicate).Take(1).ToList()
        if values.Count == 1 {
            return .Ok(values[0])
        }
        .Error(errorFactory())
    }

    // -------------------------
    // Last
    // -------------------------

    public LastOrNone() -> Option<T> {
        val values = self.ToList()
        if values.Count == 0 {
            return .None
        }
        .Some(values[values.Count - 1])
    }

    public LastOrNone(predicate: T -> bool) -> Option<T> {
        val values = self.Where(predicate).ToList()
        if values.Count == 0 {
            return .None
        }
        .Some(values[values.Count - 1])
    }

    public LastOrError<E>(errorFactory: () -> E) -> Result<T, E> {
        val values = self.ToList()
        if values.Count == 0 {
            return .Error(errorFactory())
        }
        .Ok(values[values.Count - 1])
    }

    public LastOrError<E>(predicate: T -> bool, errorFactory: () -> E) -> Result<T, E> {
        val values = self.Where(predicate).ToList()
        if values.Count == 0 {
            return .Error(errorFactory())
        }
        .Ok(values[values.Count - 1])
    }

    // -------------------------
    // Single
    // -------------------------

    public SingleOrNone() -> Option<T> {
        val values = self.Take(2).ToList()
        if values.Count == 1 {
            return .Some(values[0])
        }
        .None
    }

    public SingleOrNone(predicate: T -> bool) -> Option<T> {
        val values = self.Where(predicate).Take(2).ToList()
        if values.Count == 1 {
            return .Some(values[0])
        }
        .None
    }

    public SingleOrError<E>(errorFactory: () -> E) -> Result<T, E> {
        val values = self.Take(2).ToList()
        if values.Count == 1 {
            return .Ok(values[0])
        }
        .Error(errorFactory())
    }

    public SingleOrError<E>(predicate: T -> bool, errorFactory: () -> E) -> Result<T, E> {
        val values = self.Where(predicate).Take(2).ToList()
        if values.Count == 1 {
            return .Ok(values[0])
        }
        .Error(errorFactory())
    }

    public SingleOrError<E>(errorIfNone: () -> E, errorIfMany: () -> E) -> Result<T, E> {
        val values = self.Take(2).ToList()
        if values.Count == 1 {
            return .Ok(values[0])
        }
        if values.Count == 0 {
            return .Error(errorIfNone())
        }
        .Error(errorIfMany())
    }

    public SingleOrError<E>(predicate: T -> bool, errorIfNone: () -> E, errorIfMany: () -> E) -> Result<T, E> {
        val values = self.Where(predicate).Take(2).ToList()
        if values.Count == 1 {
            return .Ok(values[0])
        }
        if values.Count == 0 {
            return .Error(errorIfNone())
        }
        .Error(errorIfMany())
    }

    // -------------------------
    // ElementAt
    // -------------------------

    public ElementAtOrNone(index: int) -> Option<T> {
        if index < 0 {
            return .None
        }

        val values = self.Skip(index).Take(1).ToList()
        if values.Count == 1 {
            return .Some(values[0])
        }

        .None
    }

    public ElementAtOrError<E>(index: int, errorFactory: () -> E) -> Result<T, E> {
        val opt = self.ElementAtOrNone(index)
        return opt match {
            .Some(val v) => .Ok(v)
            .None => .Error(errorFactory())
        }
    }

    // -------------------------
    // Materialization with exception capture
    // -------------------------

    public ToArrayOrException() -> Result<T[], Exception> {
        try self.ToArray()
    }

    public ToArrayOrError<E>(errorFactory: Exception -> E) -> Result<T[], E> {
        try {
            return .Ok(self.ToArray())
        } catch (Exception ex) {
            return .Error(errorFactory(ex))
        }
    }

    public ToListOrException() -> Result<List<T>, Exception> {
        try self.ToList()
    }

    public ToListOrError<E>(errorFactory: Exception -> E) -> Result<List<T>, E> {
        try {
            return .Ok(self.ToList())
        } catch (Exception ex) {
            return .Error(errorFactory(ex))
        }
    }

    public ToHashSetOrException() -> Result<HashSet<T>, Exception> {
        try self.ToHashSet()
    }

    public ToHashSetOrError<E>(errorFactory: Exception -> E) -> Result<HashSet<T>, E> {
        try {
            return .Ok(self.ToHashSet())
        } catch (Exception ex) {
            return .Error(errorFactory(ex))
        }
    }

    public ToDictionaryOrException<TKey>(keySelector: T -> TKey) -> Result<Dictionary<TKey, T>, Exception> {
        try self.ToDictionary(keySelector)
    }

    public ToDictionaryOrError<TKey, E>(
        keySelector: T -> TKey,
        errorFactory: Exception -> E
    ) -> Result<Dictionary<TKey, T>, E> {
        try {
            return .Ok(self.ToDictionary(keySelector))
        } catch (Exception ex) {
            return .Error(errorFactory(ex))
        }
    }

    public ToDictionaryOrException<TKey, TValue>(
        keySelector: T -> TKey,
        elementSelector: T -> TValue
    ) -> Result<Dictionary<TKey, TValue>, Exception> {
        try self.ToDictionary(keySelector, elementSelector)
    }

    public ToDictionaryOrError<TKey, TValue, E>(
        keySelector: T -> TKey,
        elementSelector: T -> TValue,
        errorFactory: Exception -> E
    ) -> Result<Dictionary<TKey, TValue>, E> {
        try {
            return .Ok(self.ToDictionary(keySelector, elementSelector))
        } catch (Exception ex) {
            return .Error(errorFactory(ex))
        }
    }
}
