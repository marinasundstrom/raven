namespace System.Linq

import System.*
import System.Linq.*
import System.Collections.Generic.*

public extension EnumerableOption<T> for IEnumerable<T> {

    // -------------------------
    // First
    // -------------------------

    // Captures the first element, or none. May throw.
    // .Some(x)   => first element
    // .None      => no elements
    public FirstOrNone() -> Option<T> {
        val values = self.Take(1).ToList()
        if values.Count == 1 {
            return .Some(values[0])
        }
        .None
    }

    // Captures the first element on predicate, or none. May throw.
    // .Some(x)   => first element
    // .None      => no elements
    public FirstOrNone(predicate: T -> bool) -> Option<T> {
        val values = self.Where(predicate).Take(1).ToList()
        if values.Count == 1 {
            return .Some(values[0])
        }
        .None
    }

    // -------------------------
    // First (exception-capturing)
    // -------------------------

    // Captures enumeration exceptions. Never throws.
    // .Ok(.None)      => no elements
    // .Ok(.Some(x))   => first element
    // .Error(ex)      => enumeration threw
    public TryFirstOrNone() -> Result<Option<T>, Exception> {
        try {
            use e = self.GetEnumerator()
            if e.MoveNext() {
                return .Ok(.Some(e.Current))
            }
            return .Ok(.None)
        } catch (Exception ex) {
            return .Error(ex)
        }
    }

    // Captures enumeration/predicate exceptions. Never throws.
    public TryFirstOrNone(predicate: T -> bool) -> Result<Option<T>, Exception> {
        try {
            use e = self.GetEnumerator()
            while e.MoveNext() {
                val item = e.Current
                if predicate(item) {
                    return .Ok(.Some(item))
                }
            }
            return .Ok(.None)
        } catch (Exception ex) {
            return .Error(ex)
        }
    }

    // Captures exceptions and maps them (and/or absence) into E.
    // errorFactory(.None)      => no elements / no match
    // errorFactory(.Some(ex))  => enumeration/predicate threw
    public TryFirstOrError<E>(errorFactory: Option<Exception> -> E) -> Result<Option<T>, E> {
        return self.TryFirstOrNone() match {
            .Ok(val opt) => opt match {
                .Some(val item) => .Ok(.Some(item))
                .None => .Error(errorFactory(.None))
            }
            .Error(val ex) => .Error(errorFactory(.Some(ex)))
        }
    }

    public TryFirstOrError<E>(predicate: T -> bool, errorFactory: Option<Exception> -> E) -> Result<Option<T>, E> {
        try {
            use e = self.GetEnumerator()
            while e.MoveNext() {
                val item = e.Current
                if predicate(item) {
                    return .Ok(.Some(item))
                }
            }
            return .Error(errorFactory(.None))
        } catch (Exception ex) {
            return .Error(errorFactory(.Some(ex)))
        }
    }

    public FirstOrError<E>(errorFactory: () -> E) -> Result<T, E> {
        val values = self.Take(1).ToList()
        if values.Count == 1 {
            return .Ok(values[0])
        }
        .Error(errorFactory())
    }

    public FirstOrError<E>(predicate: T -> bool, errorFactory: () -> E) -> Result<T, E> {
        val values = self.Where(predicate).Take(1).ToList()
        if values.Count == 1 {
            return .Ok(values[0])
        }
        .Error(errorFactory())
    }

    // -------------------------
    // Last
    // -------------------------

    public LastOrNone() -> Option<T> {
        val values = self.ToList()
        if values.Count == 0 {
            return .None
        }
        .Some(values[values.Count - 1])
    }

    public LastOrNone(predicate: T -> bool) -> Option<T> {
        val values = self.Where(predicate).ToList()
        if values.Count == 0 {
            return .None
        }
        .Some(values[values.Count - 1])
    }

    // -------------------------
    // Last (exception-capturing)
    // -------------------------

    public TryLastOrNone() -> Result<Option<T>, Exception> {
        try {
            use e = self.GetEnumerator()
            if !e.MoveNext() {
                return .Ok(.None)
            }
            var last = e.Current
            while e.MoveNext() {
                last = e.Current
            }
            return .Ok(.Some(last))
        } catch (Exception ex) {
            return .Error(ex)
        }
    }

    public TryLastOrNone(predicate: T -> bool) -> Result<Option<T>, Exception> {
        try {
            use e = self.GetEnumerator()
            var has = false
            var last = default(T)
            while e.MoveNext() {
                val item = e.Current
                if predicate(item) {
                    last = item
                    has = true
                }
            }
            if has {
                return .Ok(.Some(last))
            }
            return .Ok(.None)
        } catch (Exception ex) {
            return .Error(ex)
        }
    }

    public TryLastOrError<E>(errorFactory: Option<Exception> -> E) -> Result<Option<T>, E> {
        return self.TryLastOrNone() match {
            .Ok(val opt) => opt match {
                .Some(val item) => .Ok(.Some(item))
                .None => .Error(errorFactory(.None))
            }
            .Error(val ex) => .Error(errorFactory(.Some(ex)))
        }
    }

    public TryLastOrError<E>(predicate: T -> bool, errorFactory: Option<Exception> -> E) -> Result<Option<T>, E> {
        try {
            use e = self.GetEnumerator()
            var has = false
            var last = default(T)
            while e.MoveNext() {
                val item = e.Current
                if predicate(item) {
                    last = item
                    has = true
                }
            }
            if has {
                return .Ok(.Some(last))
            }
            return .Error(errorFactory(.None))
        } catch (Exception ex) {
            return .Error(errorFactory(.Some(ex)))
        }
    }

    public LastOrError<E>(errorFactory: () -> E) -> Result<T, E> {
        val values = self.ToList()
        if values.Count == 0 {
            return .Error(errorFactory())
        }
        .Ok(values[values.Count - 1])
    }

    public LastOrError<E>(predicate: T -> bool, errorFactory: () -> E) -> Result<T, E> {
        val values = self.Where(predicate).ToList()
        if values.Count == 0 {
            return .Error(errorFactory())
        }
        .Ok(values[values.Count - 1])
    }

    // -------------------------
    // Single
    // -------------------------

    public SingleOrNone() -> Option<T> {
        val values = self.Take(2).ToList()
        if values.Count == 1 {
            return .Some(values[0])
        }
        .None
    }

    public SingleOrNone(predicate: T -> bool) -> Option<T> {
        val values = self.Where(predicate).Take(2).ToList()
        if values.Count == 1 {
            return .Some(values[0])
        }
        .None
    }

    // -------------------------
    // Single (exception-capturing)
    // -------------------------

    public TrySingleOrNone() -> Result<Option<T>, Exception> {
        try {
            use e = self.GetEnumerator()
            if !e.MoveNext() {
                return .Ok(.None)
            }
            val first = e.Current
            if e.MoveNext() {
                return .Ok(.None)
            }
            return .Ok(.Some(first))
        } catch (Exception ex) {
            return .Error(ex)
        }
    }

    public TrySingleOrNone(predicate: T -> bool) -> Result<Option<T>, Exception> {
        try {
            use e = self.GetEnumerator()
            var found = false
            var single = default(T)
            while e.MoveNext() {
                val item = e.Current
                if predicate(item) {
                    if found {
                        return .Ok(.None)
                    }
                    single = item
                    found = true
                }
            }
            if found {
                return .Ok(.Some(single))
            }
            return .Ok(.None)
        } catch (Exception ex) {
            return .Error(ex)
        }
    }

    public TrySingleOrError<E>(errorFactory: Option<Exception> -> E) -> Result<Option<T>, E> {
        return self.TrySingleOrNone() match {
            .Ok(val opt) => opt match {
                .Some(val item) => .Ok(.Some(item))
                .None => .Error(errorFactory(.None))
            }
            .Error(val ex) => .Error(errorFactory(.Some(ex)))
        }
    }

    public TrySingleOrError<E>(predicate: T -> bool, errorFactory: Option<Exception> -> E) -> Result<Option<T>, E> {
        try {
            use e = self.GetEnumerator()
            var found = false
            var single = default(T)
            while e.MoveNext() {
                val item = e.Current
                if predicate(item) {
                    if found {
                        return .Ok(.None)
                    }
                    single = item
                    found = true
                }
            }
            if found {
                return .Ok(.Some(single))
            }
            return .Error(errorFactory(.None))
        } catch (Exception ex) {
            return .Error(errorFactory(.Some(ex)))
        }
    }

    public SingleOrError<E>(errorFactory: () -> E) -> Result<T, E> {
        val values = self.Take(2).ToList()
        if values.Count == 1 {
            return .Ok(values[0])
        }
        .Error(errorFactory())
    }

    public SingleOrError<E>(predicate: T -> bool, errorFactory: () -> E) -> Result<T, E> {
        val values = self.Where(predicate).Take(2).ToList()
        if values.Count == 1 {
            return .Ok(values[0])
        }
        .Error(errorFactory())
    }

    public SingleOrError<E>(errorIfNone: () -> E, errorIfMany: () -> E) -> Result<T, E> {
        val values = self.Take(2).ToList()
        if values.Count == 1 {
            return .Ok(values[0])
        }
        if values.Count == 0 {
            return .Error(errorIfNone())
        }
        .Error(errorIfMany())
    }

    public SingleOrError<E>(predicate: T -> bool, errorIfNone: () -> E, errorIfMany: () -> E) -> Result<T, E> {
        val values = self.Where(predicate).Take(2).ToList()
        if values.Count == 1 {
            return .Ok(values[0])
        }
        if values.Count == 0 {
            return .Error(errorIfNone())
        }
        .Error(errorIfMany())
    }

    // -------------------------
    // ElementAt
    // -------------------------

    public ElementAtOrNone(index: int) -> Option<T> {
        if index < 0 {
            return .None
        }

        val values = self.Skip(index).Take(1).ToList()
        if values.Count == 1 {
            return .Some(values[0])
        }

        .None
    }

    public TryElementAtOrNone(index: int) -> Result<Option<T>, Exception> {
        if index < 0 {
            return .Ok(.None)
        }

        try {
            use e = self.GetEnumerator()
            var i = 0
            while e.MoveNext() {
                if i == index {
                    return .Ok(.Some(e.Current))
                }
                i = i + 1
            }
            return .Ok(.None)
        } catch (Exception ex) {
            return .Error(ex)
        }
    }

    public TryElementAtOrError<E>(index: int, errorFactory: Option<Exception> -> E) -> Result<Option<T>, E> {
        if index < 0 {
            return .Error(errorFactory(.None))
        }

        try {
            use e = self.GetEnumerator()
            var i = 0
            while e.MoveNext() {
                if i == index {
                    return .Ok(.Some(e.Current))
                }
                i = i + 1
            }
            return .Error(errorFactory(.None))
        } catch (Exception ex) {
            return .Error(errorFactory(.Some(ex)))
        }
    }

    public ElementAtOrError<E>(index: int, errorFactory: () -> E) -> Result<T, E> {
        val opt = self.ElementAtOrNone(index)
        return opt match {
            .Some(val v) => .Ok(v)
            .None => .Error(errorFactory())
        }
    }

    // -------------------------
    // Materialization with exception capture
    // -------------------------

    public ToArrayOrException() -> Result<T[], Exception> {
        try self.ToArray()
    }

    public ToArrayOrError<E>(errorFactory: Exception -> E) -> Result<T[], E> {
        try {
            return .Ok(self.ToArray())
        } catch (Exception ex) {
            return .Error(errorFactory(ex))
        }
    }

    public ToListOrException() -> Result<List<T>, Exception> {
        try self.ToList()
    }

    public ToListOrError<E>(errorFactory: Exception -> E) -> Result<List<T>, E> {
        try {
            return .Ok(self.ToList())
        } catch (Exception ex) {
            return .Error(errorFactory(ex))
        }
    }

    public ToHashSetOrException() -> Result<HashSet<T>, Exception> {
        try self.ToHashSet()
    }

    public ToHashSetOrError<E>(errorFactory: Exception -> E) -> Result<HashSet<T>, E> {
        try {
            return .Ok(self.ToHashSet())
        } catch (Exception ex) {
            return .Error(errorFactory(ex))
        }
    }

    public ToDictionaryOrException<TKey>(keySelector: T -> TKey) -> Result<Dictionary<TKey, T>, Exception> {
        try self.ToDictionary(keySelector)
    }

    public ToDictionaryOrError<TKey, E>(
        keySelector: T -> TKey,
        errorFactory: Exception -> E
    ) -> Result<Dictionary<TKey, T>, E> {
        try {
            return .Ok(self.ToDictionary(keySelector))
        } catch (Exception ex) {
            return .Error(errorFactory(ex))
        }
    }

    public ToDictionaryOrException<TKey, TValue>(
        keySelector: T -> TKey,
        elementSelector: T -> TValue
    ) -> Result<Dictionary<TKey, TValue>, Exception> {
        try self.ToDictionary(keySelector, elementSelector)
    }

    public ToDictionaryOrError<TKey, TValue, E>(
        keySelector: T -> TKey,
        elementSelector: T -> TValue,
        errorFactory: Exception -> E
    ) -> Result<Dictionary<TKey, TValue>, E> {
        try {
            return .Ok(self.ToDictionary(keySelector, elementSelector))
        } catch (Exception ex) {
            return .Error(errorFactory(ex))
        }
    }
}
