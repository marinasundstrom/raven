namespace System

import System.*

/// Represents some value, or no value.
///
/// ## Usage
/// Use `Option` like so:
///
/// ```raven
/// func Test(v: int) -> Option<int> {
///     if v > 3 {
///         return .Some(42)
///     }
///     return .None
/// }
/// ```
/// 
/// Matching result in `match` expression:
/// 
/// ```raven
/// val result = Test(2)
/// 
/// val r = result match {
///     .Some(val value) => "Some: $value"
///     .None => "None"
/// }
/// ```
///
/// Simple pattern:
///
/// ```raven
/// if result is .Some(val value) {
///     // Omitted
/// } else if result is .None {
///     // Omitted
/// }
/// ```
public union Option<T> {
    /// Represents some value
    Some(value: T)

    /// Represents the absence of a value
    None
}

/// Contains extensions for the Option<T> type
public extension OptionExtensions<T> for Option<T> {

    /// Gets a value indicating whether the Option has Some
    public HasSome: bool {
        get => self is .Some(val v)
    }

    /// Gets a value indicating whether the Option has None
    public HasNone: bool {
        get => self is .None
    }

    public IsOkOr<E>(error: E) -> Result<T, E> {
        if self is .Some(val v2) {
            return .Ok(v2)
        }

        return .Error(error)    
    }

    public IsOkOr<E>(errorFactory: () -> E) -> Result<T, E> {
        if self is .Some(val v2) {
            return .Ok(v2)
        }

        return .Error(errorFactory())    
    }

    /// Unwrap the value if Some, otherwise return the default value
    public UnwrapOrDefault() -> T {
        if self is .Some(val value) {
            return value
        }

        return default(T)
    }

    /// Unwrap the value if Some, otherwise throw an exception
    public UnwrapOrThrow() -> T {
        if self is .Some(val value) {
            return value
        }

        throw new InvalidOperationException("Option is None")
    }

    /// Unwrap the value if Some, otherwise return the specified value
    public UnwrapOr(defaultValue: T) -> T {
        if self is .Some(val value) {
            return value
        }

        return defaultValue
    }
}


public extension OptionExtensions1<T : class> for Option<T> {

    public static implicit operator(opt: Option<T>) -> T? {
        if opt is .Some(val value) {
            return value
        }
        return null
    }

    public static implicit operator(value: T?) -> Option<T> {
        if value is not null {
            return .Some(value)
        }
        return .None
    }
}

public extension OptionExtensions2<T : struct> for Option<T> {

    public static implicit operator(opt: Option<T>) -> T? {
        if opt is .Some(val value) {
            return value
        }
        return null
    }

    /*
    public static implicit operator(value: T?) -> Option<T> {
        // TODO: Handle so that value type in "value" gets unwrapped
        if value is not null {
            return .Some(value)
        }
        return .None
    }
    */
}
