namespace System

import System.*

/// Represents some value, or no value.
///
/// ## Usage
/// Use `Option` like so:
///
/// ```raven
/// func Test(v: int) -> Option<int> {
///     if v > 3 {
///         return .Some(42)
///     }
///     return .None
/// }
/// ```
/// 
/// Matching result in `match` expression:
/// 
/// ```raven
/// val result = Test(2)
/// 
/// val r = result match {
///     .Some(value) => "Some: $value"
///     .None => "None"
/// }
/// ```
///
/// Simple pattern:
///
/// ```raven
/// if result is .Some(value) {
///     // Omitted
/// } else if result is .None {
///     // Omitted
/// }
/// ```
public union Option<T> {
    /// Represents some value
    Some(value: T)

    /// Represents the absence of a value
    None
}

/// Contains extensions for the Option<T> type
public extension OptionExtensions<T> for Option<T> {

    /// Unwrap the value if Some, otherwise return the default value
    public UnwrapOrDefault() -> T {
        if self is .Some(value) {
            return value
        }

        return default(T)
    }

    /// Unwrap the value if Some, otherwise throw an exception
    public UnwrapOrThrow() -> T {
        if self is .Some(value) {
            return value
        }

        throw new InvalidOperationException("Option is None")
    }

    /// Unwrap the value if Some, otherwise return the specified value
    public UnwrapOr(defaultValue: T) -> T {
        if self is .Some(value) {
            return value
        }

        return defaultValue
    }
}


public extension OptionExtensions1<T : class> for Option<T> {

    public static implicit operator(opt: Option<T>) -> T? {
        if opt is .Some(value) {
            return value
        }
        return null
    }
}

public extension OptionExtensions2<T : struct> for Option<T> {

    public static implicit operator(opt: Option<T>) -> T? {
        if opt is .Some(value) {
            return value
        }
        return null
    }
}
