# System.Reflection2

System.Reflection2 provides a metadata-only layer that mirrors the public surface of the most common reflection types so Raven's compiler can reason about assemblies without loading them into the runtime. `MetadataLoadContext` owns the cache of metadata-backed assemblies, while `MetadataAssembly` and `MetadataModule` expose the familiar `Assembly`/`Module` APIs over `MetadataReader` instances.【F:src/System.Reflection2/System/Reflection2/MetadataLoadContext.cs†L8-L115】【F:src/System.Reflection2/System/Reflection2/MetadataAssembly.cs†L9-L88】

## Core building blocks

- **MetadataLoadContext** – registers assemblies from `MetadataReader` or `MetadataReaderProvider` instances and resolves dependencies through an `IMetadataAssemblyResolver` implementation.【F:src/System.Reflection2/System/Reflection2/MetadataLoadContext.cs†L23-L91】  Use `RegisterAssembly` when you already hold a reader, or hand it a `MetadataResolutionResult` produced by a resolver to keep the provider alive for the load context.
- **MetadataAssembly / MetadataModule** – surface a metadata-backed `Assembly` that exposes modules and types without JIT-loading code, and delegate type resolution back through the load context for cross-assembly references.【F:src/System.Reflection2/System/Reflection2/MetadataAssembly.cs†L20-L63】【F:src/System.Reflection2/System/Reflection2/MetadataModule.cs†L10-L84】  `MetadataModule` also fabricates constructed array, pointer, by-ref, and generic types on demand so symbol analysis can operate on closed type shapes.【F:src/System.Reflection2/System/Reflection2/MetadataModule.cs†L15-L89】
- **MetadataType/Method/Property/Field** – provide reflection objects backed purely by metadata tables. They supply names, signatures, members, and generic construction logic required by the symbol layer, while deliberately omitting runtime-only behaviors such as invocation.【F:src/System.Reflection2/System/Reflection2/MetadataType.cs†L11-L378】【F:src/System.Reflection2/System/Reflection2/MetadataMethodInfo.cs†L11-L187】【F:src/System.Reflection2/System/Reflection2/MetadataPropertyInfo.cs†L9-L156】【F:src/System.Reflection2/System/Reflection2/MetadataFieldInfo.cs†L9-L69】
- **PathMetadataAssemblyResolver** – indexes directories or individual DLLs so the load context can resolve assembly references by simple name without touching the runtime loader.【F:src/System.Reflection2/System/Reflection2/PathMetadataAssemblyResolver.cs†L10-L99】
- **PersistedAssemblyBuilderExtensions** – turns a `PersistedAssemblyBuilder` into an in-memory `MetadataAssembly`, enabling dynamic IL generation tests to interrogate the produced metadata immediately.【F:src/System.Reflection2/System/Reflection2/PersistedAssemblyBuilderExtensions.cs†L8-L40】

## How it differs from System.Reflection

System.Reflection2 intentionally implements only the metadata surface Raven needs today. Important behavioral differences from the runtime reflection stack include:

- **No runtime invocation or handles.** Attempting to invoke metadata-backed methods, constructors, properties, or fields, or to access runtime handles, throws `NotSupportedException` because the context has no backing execution environment.【F:src/System.Reflection2/System/Reflection2/MetadataMethodInfo.cs†L65-L134】【F:src/System.Reflection2/System/Reflection2/MetadataConstructorInfo.cs†L30-L54】【F:src/System.Reflection2/System/Reflection2/MetadataPropertyInfo.cs†L75-L82】【F:src/System.Reflection2/System/Reflection2/MetadataFieldInfo.cs†L31-L62】
- **Custom attributes are metadata-first with optional instantiation.** `CustomAttributeData` is decoded for types, members, and parameters without invoking constructors, and `GetCustomAttributes`/`IsDefined` delegate to `MetadataLoadContext.RuntimeBridge` when configured so callers can materialize real attribute instances (including inherited walks). Without a bridge, metadata-only usage still throws to avoid implying runtime support.【F:src/System.Reflection2/System/Reflection2/MetadataType.cs†L138-L166】【F:src/System.Reflection2/System/Reflection2/MetadataMethodInfo.cs†L73-L120】【F:src/System.Reflection2/System/Reflection2/MetadataParameterInfo.cs†L13-L116】【F:src/System.Reflection2/System/Reflection2/MetadataLoadContext.cs†L27-L37】 Enum-typed arguments retain their metadata enum types, materializing runtime values when available and otherwise exposing the raw underlying value for metadata-only inspection.【F:src/System.Reflection2/System/Reflection2/MetadataCustomAttributeData.cs†L67-L118】
- **Events and interface maps mirror metadata semantics.** Metadata-backed types now expose `EventInfo` wrappers and populate `GetInterfaceMap` by decoding method implementation records, while invocation remains unsupported in metadata-only mode.【F:src/System.Reflection2/System/Reflection2/MetadataType.cs†L132-L259】【F:src/System.Reflection2/System/Reflection2/MetadataEventInfo.cs†L1-L153】
- **Type shape queries align with runtime reflection.** Array, pointer, and by-ref constructions reuse cached helpers so `GetElementType`, `GetArrayRank`, and related APIs behave like `System.Reflection`, including on nested generics and pointer combinations.【F:src/System.Reflection2/System/Reflection2/MetadataType.cs†L206-L361】【F:test/System.Reflection2.Tests/PersistedAssemblyBuilderTests.cs†L49-L172】
- **Signature support now covers modern shapes.** Function-pointer signatures materialize as metadata-only `MetadataFunctionPointerType` instances, generic parameters fall back to placeholders when context arrays are missing, and default parameter constants are decoded instead of reporting `DBNull.Value`.【F:src/System.Reflection2/System/Reflection2/MetadataFunctionPointerType.cs†L1-L143】【F:src/System.Reflection2/System/Reflection2/MetadataSignatureTypeProvider.cs†L12-L131】【F:src/System.Reflection2/System/Reflection2/MetadataSignatureGenericParameterType.cs†L1-L121】【F:src/System.Reflection2/System/Reflection2/MetadataParameterInfo.cs†L13-L103】【F:test/System.Reflection2.Tests/PersistedAssemblyBuilderTests.cs†L178-L226】
- **PersistedAssemblyBuilder stays in memory.** Unlike the BCL `MetadataLoadContext`, which expects on-disk assemblies, System.Reflection2 can project a `PersistedAssemblyBuilder` straight into metadata via `ToMetadataAssembly`, enabling emit pipelines and tests to interrogate IL without ever writing a PE to disk.【F:src/System.Reflection2/System/Reflection2/PersistedAssemblyBuilderExtensions.cs†L8-L40】【F:test/System.Reflection2.Tests/PersistedAssemblyBuilderTests.cs†L12-L115】
- **Optional runtime bridges enable invocation.** `MetadataLoadContext.RuntimeBridge` lets callers plug in `IMetadataRuntimeBridge` implementations such as `RuntimeReflectionBridge` so metadata-backed members can delegate invocation, field access, and event wiring to a runtime reflection stack when available. Binder conversions and culture-sensitive coercions flow straight through the bridge, so caller-supplied `Binder` implementations behave exactly as they do with runtime reflection.【F:src/System.Reflection2/System/Reflection2/MetadataLoadContext.cs†L11-L66】【F:src/System.Reflection2/System/Reflection2/IMetadataRuntimeBridge.cs†L1-L33】【F:src/System.Reflection2/System/Reflection2/RuntimeReflectionBridge.cs†L12-L199】【F:test/System.Reflection2.Tests/PersistedAssemblyBuilderTests.cs†L126-L174】

## Caveats and roadmap

To become a true drop-in replacement for runtime reflection in the symbol layer, System.Reflection2 still needs:

1. **Attribute instantiation bridges** – ✅ Metadata-only surfaces now delegate `GetCustomAttributes`/`IsDefined` to the runtime bridge when one is available, enabling attribute materialization and inherited queries without changing the metadata-only default behavior.【F:src/System.Reflection2/System/Reflection2/MetadataType.cs†L145-L185】【F:src/System.Reflection2/System/Reflection2/MetadataMethodInfo.cs†L86-L126】【F:src/System.Reflection2/System/Reflection2/RuntimeReflectionBridge.cs†L78-L263】
2. **Polish advanced member semantics** – harden inherited-event discovery, default interface implementations, and other reflection edge cases so APIs like Roslyn's symbol display can rely on metadata parity with runtime reflection.【F:src/System.Reflection2/System/Reflection2/MetadataType.cs†L157-L361】【F:src/System.Reflection2/System/Reflection2/MetadataEventInfo.cs†L1-L153】
3. **Signature polish** – extend decoding to surface custom modifiers, unmanaged calling-convention metadata, and other advanced forms so metadata signatures match runtime fidelity in edge cases.【F:src/System.Reflection2/System/Reflection2/MetadataSignatureTypeProvider.cs†L12-L131】【F:src/System.Reflection2/System/Reflection2/MetadataFunctionPointerType.cs†L1-L143】
4. **Optional runtime bridges** – if callers require invocation or runtime handles, additional shims would be needed to project metadata onto lightweight runtime stubs or to plug into a reflection execution layer.【F:src/System.Reflection2/System/Reflection2/MetadataMethodInfo.cs†L65-L134】【F:src/System.Reflection2/System/Reflection2/MetadataFieldInfo.cs†L31-L62】

### Integration roadmap

The immediate goal is to deliver the remaining metadata fidelity that Raven's PE symbol layer expects from runtime reflection. The work breaks down into the following tracks:

1. **Attribute materialization bridge** – ✅ Completed. Metadata members and parameters now delegate `GetCustomAttributes`/`IsDefined` to the configured runtime bridge, allowing Raven’s `PE*Symbol` layer to observe instantiated attributes (including `inherit: true` walks) while metadata-only contexts continue to throw to signal unsupported execution paths.【F:src/System.Reflection2/System/Reflection2/MetadataParameterInfo.cs†L70-L116】【F:src/System.Reflection2/System/Reflection2/MetadataType.cs†L138-L166】【F:src/System.Reflection2/System/Reflection2/RuntimeReflectionBridge.cs†L90-L185】

2. **Override and interface semantics polish** – ✅ Completed.
   - `MetadataMethodInfo.GetBaseDefinition` now resolves metadata inheritance chains so overrides report their original slot rather than their declaring definition.【F:src/System.Reflection2/System/Reflection2/MetadataMethodInfo.cs†L125-L177】
   - `MetadataType.GetInterfaceMap` handles explicit implementations and default interface methods, propagating interface targets without leaking runtime-specific exceptions.【F:src/System.Reflection2/System/Reflection2/MetadataType.cs†L306-L366】【F:test/System.Reflection2.Tests/PersistedAssemblyBuilderTests.cs†L357-L418】

3. **Signature modifiers and parameter defaults** – ✅ Completed.
   - `MetadataSignatureDecoder` records required and optional custom modifiers for return values and parameters, plumbing the results through `MetadataParameterInfo.GetRequiredCustomModifiers`/`GetOptionalCustomModifiers` so Raven can observe `modreq(IsReadOnlyAttribute)` and calling-convention hints just like runtime reflection.【F:src/System.Reflection2/System/Reflection2/MetadataSignatureDecoder.cs†L1-L44】【F:src/System.Reflection2/System/Reflection2/MetadataMethodInfo.cs†L24-L368】【F:src/System.Reflection2/System/Reflection2/MetadataParameterInfo.cs†L1-L259】
   - Parameter defaults now honor metadata constants, `DecimalConstantAttribute`, `DateTimeConstantAttribute`, `DefaultParameterValueAttribute`, and optional-parameter fallbacks so `DefaultValue`/`HasDefaultValue` align with the runtime projection.【F:src/System.Reflection2/System/Reflection2/MetadataParameterInfo.cs†L70-L259】【F:test/System.Reflection2.Tests/PersistedAssemblyBuilderTests.cs†L423-L517】

4. **Constant decoding parity** – ✅ Completed.
   - `MetadataFieldInfo.GetRawConstantValue` now decodes metadata constants into real CLR values (including enum projections and decimal conversions) instead of returning raw blob handles, matching the runtime reflection behavior that Raven’s PE symbols rely on.【F:src/System.Reflection2/System/Reflection2/MetadataFieldInfo.cs†L91-L152】【F:src/Raven.CodeAnalysis/Symbols/PE/PEFieldSymbol.cs†L25-L37】
   - A regression test exercises numeric, string, enum, null, and decimal literals to ensure metadata-only projections stay in lockstep with runtime reflection expectations and continue throwing for non-literal fields.【F:test/System.Reflection2.Tests/PersistedAssemblyBuilderTests.cs†L814-L882】

5. **Integration hardening** – ✅ Completed.
   - Raven’s compilation pipeline can now choose between the runtime `MetadataLoadContext` and System.Reflection2 via the `MetadataReferenceHostKind` option, allowing PE symbols to hydrate from either reflection stack without code changes.【F:src/Raven.CodeAnalysis/CompilationOptions.cs†L5-L60】【F:src/Raven.CodeAnalysis/MetadataReferenceHost.cs†L1-L155】
   - A cross-stack regression test instantiates `Compilation` with both hosts and asserts the projected `System.String` methods stay in sync, ensuring the PE symbol suite observes the same metadata surface when backed by System.Reflection2.【F:test/Raven.CodeAnalysis.Tests/Symbols/SystemReflection2IntegrationTests.cs†L1-L48】

### Raven PE*Symbol integration requirements

Raven’s metadata-backed symbol layer has a few additional expectations before System.Reflection2 can replace the runtime reflection types in `PE*Symbol` implementations:

System.Reflection2 now projects members, parameters, signatures, constants, and runtime-bridge invocation well enough for Raven’s symbol layer, but a few baseline APIs still diverge from the runtime reflection stack:

1. **Assembly and module metadata parity.** ✅ `MetadataAssembly` now exposes assembly-level custom-attribute metadata, manifest-resource enumeration, and manifest-resource descriptors while keeping stream materialization disabled in metadata-only contexts.【F:src/System.Reflection2/System/Reflection2/MetadataAssembly.cs†L21-L206】 `MetadataModule` surfaces module attributes, determines whether a module is resource-only, and implements the public token-resolution surface (`ResolveType/Method/Field/Member`, `ResolveSignature`, and `ResolveString`) by delegating to the existing metadata decoders.【F:src/System.Reflection2/System/Reflection2/MetadataModule.cs†L21-L363】
2. **Public token resolution APIs.** ✅ `MetadataModule` now overrides the `ResolveType/Method/Field/Member` family, `ResolveSignature`, and `ResolveString`, delegating each call through the existing metadata decoders so token translation mirrors runtime reflection.【F:src/System.Reflection2/System/Reflection2/MetadataModule.cs†L80-L136】
3. **Method and constructor identity.** ✅ `MetadataMethodInfo`/`MetadataConstructorInfo` expose stable `MetadataToken` values and surface metadata-backed method bodies via `MetadataMethodBody`, enabling `GetMethodBody`, local-variable inspection, exception-clause enumeration, and IL retrieval without leaving the metadata stack.【F:src/System.Reflection2/System/Reflection2/MetadataMethodInfo.cs†L52-L134】【F:src/System.Reflection2/System/Reflection2/MetadataConstructorInfo.cs†L32-L142】【F:src/System.Reflection2/System/Reflection2/MetadataMethodBody.cs†L11-L189】 `MethodHandle` remains unsupported in metadata-only mode; callers still require a runtime bridge for execution-centric scenarios.【F:src/System.Reflection2/System/Reflection2/MetadataMethodInfo.cs†L73-L120】
4. **Member-level modifiers and marshalling.** Parameter signatures now carry custom modifiers, but properties always return empty modifier arrays and fields never decode signature-level modifiers or marshalling descriptors, so metadata that Roslyn and reflection consumers rely on (readonly returns, ref modifiers, `MarshalAs`, etc.) is still missing.【F:src/System.Reflection2/System/Reflection2/MetadataPropertyInfo.cs†L144-L146】【F:src/System.Reflection2/System/Reflection2/MetadataFieldInfo.cs†L9-L152】
5. **Type identity helpers.** `MetadataType.GUID` currently returns `Guid.Empty`, and we do not yet surface COM/import metadata, default members, or layout information beyond raw `TypeAttributes`, so scenarios that depend on `Type.GUID`, `Type.GetDefaultMembers`, or `StructLayoutAttribute` parity still need additional decoding.【F:src/System.Reflection2/System/Reflection2/MetadataType.cs†L69-L190】

## Relationship to System.Reflection.MetadataLoadContext

While the BCL's `System.Reflection.MetadataLoadContext` exposes runtime-compatible proxies, System.Reflection2 keeps the metadata experience explicitly detached from the runtime:

- `MetadataLoadContext` requires callers to register `MetadataReader` instances or providers, keeping ownership of metadata streams inside the compiler instead of reading assemblies through file-system helpers.【F:src/System.Reflection2/System/Reflection2/MetadataLoadContext.cs†L20-L55】
- Reflection surfaces are purpose-built metadata-only types (`MetadataType`, `MetadataMethodInfo`, etc.) that short-circuit runtime behaviors unless a bridge is supplied, making the default experience safe for compilation without accidental execution.【F:src/System.Reflection2/System/Reflection2/MetadataType.cs†L11-L259】【F:src/System.Reflection2/System/Reflection2/MetadataMethodInfo.cs†L11-L155】
- When runtime behavior is required, consumers explicitly opt in via `MetadataLoadContext.RuntimeBridge` and can reuse `RuntimeReflectionBridge` to forward metadata objects to real runtime reflection APIs, keeping invocation an additive capability instead of a baseline requirement.【F:src/System.Reflection2/System/Reflection2/MetadataLoadContext.cs†L11-L66】【F:src/System.Reflection2/System/Reflection2/RuntimeReflectionBridge.cs†L1-L168】
- System.Reflection2 keeps persisted assemblies entirely in memory; `PersistedAssemblyBuilderExtensions.ToMetadataAssembly` hands the load context a `MetadataReader` without touching the disk, whereas `System.Reflection.MetadataLoadContext` expects file-backed assemblies or pre-materialized readers from external sources.【F:src/System.Reflection2/System/Reflection2/PersistedAssemblyBuilderExtensions.cs†L8-L40】

## Usage

The unit tests demonstrate the intended flow: build a dynamic assembly with `PersistedAssemblyBuilder`, convert it to a `MetadataAssembly`, and query the resulting metadata types just like runtime reflection, including generic instantiation and array/by-ref construction.【F:test/System.Reflection2.Tests/PersistedAssemblyBuilderTests.cs†L12-L189】【F:src/System.Reflection2/System/Reflection2/PersistedAssemblyBuilderExtensions.cs†L8-L40】 Create a `MetadataLoadContext` with a resolver (for example, `PathMetadataAssemblyResolver`) to supply reference assemblies before calling `ToMetadataAssembly`.【F:test/System.Reflection2.Tests/PersistedAssemblyBuilderTests.cs†L193-L217】【F:src/System.Reflection2/System/Reflection2/PathMetadataAssemblyResolver.cs†L17-L67】 When invocation is required, attach a bridge such as `RuntimeReflectionBridge` to `MetadataLoadContext.RuntimeBridge` and map metadata types back to their runtime counterparts; binder conversions and culture-specific coercions flow across this bridge so custom `Binder` implementations can participate in argument conversion or overload resolution.【F:test/System.Reflection2.Tests/PersistedAssemblyBuilderTests.cs†L126-L174】【F:src/System.Reflection2/System/Reflection2/RuntimeReflectionBridge.cs†L12-L199】

### Sample: emit and execute Hello World

The `samples/Reflection2HelloWorld` console app shows the full workflow: it builds a `PersistedAssemblyBuilder`, inspects the generated type through System.Reflection2, writes a runnable `HelloReflection2.dll`, and emits the accompanying runtime configuration so `dotnet` can execute the generated program.【F:samples/Reflection2HelloWorld/Program.cs†L1-L87】 Run it with `dotnet run --project samples/Reflection2HelloWorld -- <outputPath>` and then execute the produced assembly with `dotnet <outputPath>` to print `Hello from Reflection2!`.【F:samples/Reflection2HelloWorld/Program.cs†L4-L87】

### Unsupported scenarios

- Runtime handles (`TypeHandle`, `MethodHandle`, etc.) remain unavailable in metadata-only mode; callers must use a runtime bridge if handles or invocation are required.【F:src/System.Reflection2/System/Reflection2/MetadataMethodInfo.cs†L69-L134】【F:src/System.Reflection2/System/Reflection2/MetadataFieldInfo.cs†L31-L74】
- Materializing attribute instances requires a runtime bridge; without one `GetCustomAttributes` continues to throw to preserve metadata-only safety.【F:src/System.Reflection2/System/Reflection2/MetadataType.cs†L138-L166】【F:src/System.Reflection2/System/Reflection2/MetadataMethodInfo.cs†L73-L120】
- Advanced runtime behaviors such as `Type.MakeGenericType` over open generic parameters with missing context, custom modifiers, and reflection emit execution helpers are still on the roadmap and may require additional shims before parity with the runtime stack.【F:src/System.Reflection2/System/Reflection2/MetadataSignatureTypeProvider.cs†L12-L131】【F:src/System.Reflection2/System/Reflection2/MetadataFunctionPointerType.cs†L1-L143】
