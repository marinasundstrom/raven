# System.Reflection2

System.Reflection2 provides a metadata-only layer that mirrors the public surface of the most common reflection types so Raven's compiler can reason about assemblies without loading them into the runtime. `MetadataLoadContext` owns the cache of metadata-backed assemblies, while `MetadataAssembly` and `MetadataModule` expose the familiar `Assembly`/`Module` APIs over `MetadataReader` instances.【F:src/System.Reflection2/System/Reflection2/MetadataLoadContext.cs†L8-L115】【F:src/System.Reflection2/System/Reflection2/MetadataAssembly.cs†L9-L88】

## Core building blocks

- **MetadataLoadContext** – registers assemblies from `MetadataReader` or `MetadataReaderProvider` instances and resolves dependencies through an `IMetadataAssemblyResolver` implementation.【F:src/System.Reflection2/System/Reflection2/MetadataLoadContext.cs†L23-L91】  Use `RegisterAssembly` when you already hold a reader, or hand it a `MetadataResolutionResult` produced by a resolver to keep the provider alive for the load context.
- **MetadataAssembly / MetadataModule** – surface a metadata-backed `Assembly` that exposes modules and types without JIT-loading code, and delegate type resolution back through the load context for cross-assembly references.【F:src/System.Reflection2/System/Reflection2/MetadataAssembly.cs†L20-L63】【F:src/System.Reflection2/System/Reflection2/MetadataModule.cs†L10-L84】  `MetadataModule` also fabricates constructed array, pointer, by-ref, and generic types on demand so symbol analysis can operate on closed type shapes.【F:src/System.Reflection2/System/Reflection2/MetadataModule.cs†L15-L89】
- **MetadataType/Method/Property/Field** – provide reflection objects backed purely by metadata tables. They supply names, signatures, members, and generic construction logic required by the symbol layer, while deliberately omitting runtime-only behaviors such as invocation.【F:src/System.Reflection2/System/Reflection2/MetadataType.cs†L11-L378】【F:src/System.Reflection2/System/Reflection2/MetadataMethodInfo.cs†L11-L187】【F:src/System.Reflection2/System/Reflection2/MetadataPropertyInfo.cs†L9-L156】【F:src/System.Reflection2/System/Reflection2/MetadataFieldInfo.cs†L9-L69】
- **PathMetadataAssemblyResolver** – indexes directories or individual DLLs so the load context can resolve assembly references by simple name without touching the runtime loader.【F:src/System.Reflection2/System/Reflection2/PathMetadataAssemblyResolver.cs†L10-L99】
- **PersistedAssemblyBuilderExtensions** – turns a `PersistedAssemblyBuilder` into an in-memory `MetadataAssembly`, enabling dynamic IL generation tests to interrogate the produced metadata immediately.【F:src/System.Reflection2/System/Reflection2/PersistedAssemblyBuilderExtensions.cs†L8-L40】

## How it differs from System.Reflection

System.Reflection2 intentionally implements only the metadata surface Raven needs today. Important behavioral differences from the runtime reflection stack include:

- **No runtime invocation or handles.** Attempting to invoke metadata-backed methods, constructors, properties, or fields, or to access runtime handles, throws `NotSupportedException` because the context has no backing execution environment.【F:src/System.Reflection2/System/Reflection2/MetadataMethodInfo.cs†L65-L134】【F:src/System.Reflection2/System/Reflection2/MetadataConstructorInfo.cs†L30-L54】【F:src/System.Reflection2/System/Reflection2/MetadataPropertyInfo.cs†L75-L82】【F:src/System.Reflection2/System/Reflection2/MetadataFieldInfo.cs†L31-L62】
- **Custom attributes surface metadata only.** `CustomAttributeData` is decoded for types, members, and parameters without invoking constructors, but `GetCustomAttributes` still throws because runtime instantiation is intentionally unsupported in metadata-only mode.【F:src/System.Reflection2/System/Reflection2/MetadataType.cs†L136-L152】【F:src/System.Reflection2/System/Reflection2/MetadataMethodInfo.cs†L73-L120】【F:src/System.Reflection2/System/Reflection2/MetadataPropertyInfo.cs†L53-L98】【F:src/System.Reflection2/System/Reflection2/MetadataFieldInfo.cs†L31-L74】【F:src/System.Reflection2/System/Reflection2/MetadataParameterInfo.cs†L13-L57】 Enum-typed arguments retain their metadata enum types, materializing runtime values when available and otherwise exposing the raw underlying value for metadata-only inspection.【F:src/System.Reflection2/System/Reflection2/MetadataCustomAttributeData.cs†L67-L118】
- **Events and interface maps mirror metadata semantics.** Metadata-backed types now expose `EventInfo` wrappers and populate `GetInterfaceMap` by decoding method implementation records, while invocation remains unsupported in metadata-only mode.【F:src/System.Reflection2/System/Reflection2/MetadataType.cs†L132-L259】【F:src/System.Reflection2/System/Reflection2/MetadataEventInfo.cs†L1-L153】
- **Type shape queries align with runtime reflection.** Array, pointer, and by-ref constructions reuse cached helpers so `GetElementType`, `GetArrayRank`, and related APIs behave like `System.Reflection`, including on nested generics and pointer combinations.【F:src/System.Reflection2/System/Reflection2/MetadataType.cs†L206-L361】【F:test/System.Reflection2.Tests/PersistedAssemblyBuilderTests.cs†L49-L172】
- **Signature support now covers modern shapes.** Function-pointer signatures materialize as metadata-only `MetadataFunctionPointerType` instances, generic parameters fall back to placeholders when context arrays are missing, and default parameter constants are decoded instead of reporting `DBNull.Value`.【F:src/System.Reflection2/System/Reflection2/MetadataFunctionPointerType.cs†L1-L143】【F:src/System.Reflection2/System/Reflection2/MetadataSignatureTypeProvider.cs†L12-L131】【F:src/System.Reflection2/System/Reflection2/MetadataSignatureGenericParameterType.cs†L1-L121】【F:src/System.Reflection2/System/Reflection2/MetadataParameterInfo.cs†L13-L103】【F:test/System.Reflection2.Tests/PersistedAssemblyBuilderTests.cs†L178-L226】
- **PersistedAssemblyBuilder stays in memory.** Unlike the BCL `MetadataLoadContext`, which expects on-disk assemblies, System.Reflection2 can project a `PersistedAssemblyBuilder` straight into metadata via `ToMetadataAssembly`, enabling emit pipelines and tests to interrogate IL without ever writing a PE to disk.【F:src/System.Reflection2/System/Reflection2/PersistedAssemblyBuilderExtensions.cs†L8-L40】【F:test/System.Reflection2.Tests/PersistedAssemblyBuilderTests.cs†L12-L115】
- **Optional runtime bridges enable invocation.** `MetadataLoadContext.RuntimeBridge` lets callers plug in `IMetadataRuntimeBridge` implementations such as `RuntimeReflectionBridge` so metadata-backed members can delegate invocation, field access, and event wiring to a runtime reflection stack when available. Binder conversions and culture-sensitive coercions flow straight through the bridge, so caller-supplied `Binder` implementations behave exactly as they do with runtime reflection.【F:src/System.Reflection2/System/Reflection2/MetadataLoadContext.cs†L11-L66】【F:src/System.Reflection2/System/Reflection2/IMetadataRuntimeBridge.cs†L1-L33】【F:src/System.Reflection2/System/Reflection2/RuntimeReflectionBridge.cs†L12-L199】【F:test/System.Reflection2.Tests/PersistedAssemblyBuilderTests.cs†L126-L174】

## Caveats and roadmap

To become a true drop-in replacement for runtime reflection in the symbol layer, System.Reflection2 still needs:

1. **Attribute instantiation bridges** – now that metadata decoding is available, optionally provide hooks that can materialize attribute instances or honor `inherit: true` semantics when a runtime is present.【F:src/System.Reflection2/System/Reflection2/MetadataType.cs†L136-L152】【F:src/System.Reflection2/System/Reflection2/MetadataMethodInfo.cs†L73-L120】
2. **Polish advanced member semantics** – harden inherited-event discovery, default interface implementations, and other reflection edge cases so APIs like Roslyn's symbol display can rely on metadata parity with runtime reflection.【F:src/System.Reflection2/System/Reflection2/MetadataType.cs†L157-L361】【F:src/System.Reflection2/System/Reflection2/MetadataEventInfo.cs†L1-L153】
3. **Signature polish** – extend decoding to surface custom modifiers, unmanaged calling-convention metadata, and other advanced forms so metadata signatures match runtime fidelity in edge cases.【F:src/System.Reflection2/System/Reflection2/MetadataSignatureTypeProvider.cs†L12-L131】【F:src/System.Reflection2/System/Reflection2/MetadataFunctionPointerType.cs†L1-L143】
4. **Optional runtime bridges** – if callers require invocation or runtime handles, additional shims would be needed to project metadata onto lightweight runtime stubs or to plug into a reflection execution layer.【F:src/System.Reflection2/System/Reflection2/MetadataMethodInfo.cs†L65-L134】【F:src/System.Reflection2/System/Reflection2/MetadataFieldInfo.cs†L31-L62】

### Implementation plan

The following phased plan elaborates on how to close the remaining gaps while preserving stability for existing compiler features:

1. **Finalize attribute support**
   - Follow up with optional attribute instantiation helpers or inheritance-aware queries for consumers that need parity with runtime reflection.
   - Expand coverage tests to include cross-assembly attributes and inherited metadata once the optional behaviors exist.

2. **Fill out member surface area** – ✅ Completed. Event metadata is surfaced via `MetadataEventInfo`, interface maps decode `MethodImplementation` entries, and cached type-shape helpers answer `GetElementType`/`GetArrayRank` with regression coverage for arrays, pointers, and explicit interface implementations.【F:src/System.Reflection2/System/Reflection2/MetadataType.cs†L132-L361】【F:src/System.Reflection2/System/Reflection2/MetadataEventInfo.cs†L1-L153】【F:test/System.Reflection2.Tests/PersistedAssemblyBuilderTests.cs†L49-L172】

3. **Complete signature decoding** – ✅ Completed. Function-pointer signatures project through `MetadataFunctionPointerType`, generic placeholders are synthesized when context arrays are missing, and parameter defaults surface decoded constant values with regression coverage in the persisted-assembly tests.【F:src/System.Reflection2/System/Reflection2/MetadataFunctionPointerType.cs†L1-L143】【F:src/System.Reflection2/System/Reflection2/MetadataSignatureTypeProvider.cs†L12-L131】【F:src/System.Reflection2/System/Reflection2/MetadataSignatureGenericParameterType.cs†L1-L121】【F:src/System.Reflection2/System/Reflection2/MetadataParameterInfo.cs†L13-L103】【F:test/System.Reflection2.Tests/PersistedAssemblyBuilderTests.cs†L178-L226】

4. **Prototype optional runtime bridges** – ✅ Completed. `MetadataLoadContext.RuntimeBridge` exposes a pluggable `IMetadataRuntimeBridge` pipeline, `RuntimeReflectionBridge` projects metadata members onto runtime reflection types, and integration tests exercise method calls, constructor invocation, property and field access, event wiring, and type-level `InvokeMember` via the bridge.【F:src/System.Reflection2/System/Reflection2/MetadataLoadContext.cs†L11-L66】【F:src/System.Reflection2/System/Reflection2/RuntimeReflectionBridge.cs†L1-L168】【F:test/System.Reflection2.Tests/PersistedAssemblyBuilderTests.cs†L229-L351】

## Relationship to System.Reflection.MetadataLoadContext

While the BCL's `System.Reflection.MetadataLoadContext` exposes runtime-compatible proxies, System.Reflection2 keeps the metadata experience explicitly detached from the runtime:

- `MetadataLoadContext` requires callers to register `MetadataReader` instances or providers, keeping ownership of metadata streams inside the compiler instead of reading assemblies through file-system helpers.【F:src/System.Reflection2/System/Reflection2/MetadataLoadContext.cs†L20-L55】
- Reflection surfaces are purpose-built metadata-only types (`MetadataType`, `MetadataMethodInfo`, etc.) that short-circuit runtime behaviors unless a bridge is supplied, making the default experience safe for compilation without accidental execution.【F:src/System.Reflection2/System/Reflection2/MetadataType.cs†L11-L259】【F:src/System.Reflection2/System/Reflection2/MetadataMethodInfo.cs†L11-L155】
- When runtime behavior is required, consumers explicitly opt in via `MetadataLoadContext.RuntimeBridge` and can reuse `RuntimeReflectionBridge` to forward metadata objects to real runtime reflection APIs, keeping invocation an additive capability instead of a baseline requirement.【F:src/System.Reflection2/System/Reflection2/MetadataLoadContext.cs†L11-L66】【F:src/System.Reflection2/System/Reflection2/RuntimeReflectionBridge.cs†L1-L168】
- System.Reflection2 keeps persisted assemblies entirely in memory; `PersistedAssemblyBuilderExtensions.ToMetadataAssembly` hands the load context a `MetadataReader` without touching the disk, whereas `System.Reflection.MetadataLoadContext` expects file-backed assemblies or pre-materialized readers from external sources.【F:src/System.Reflection2/System/Reflection2/PersistedAssemblyBuilderExtensions.cs†L8-L40】

## Usage

The unit tests demonstrate the intended flow: build a dynamic assembly with `PersistedAssemblyBuilder`, convert it to a `MetadataAssembly`, and query the resulting metadata types just like runtime reflection, including generic instantiation and array/by-ref construction.【F:test/System.Reflection2.Tests/PersistedAssemblyBuilderTests.cs†L12-L189】【F:src/System.Reflection2/System/Reflection2/PersistedAssemblyBuilderExtensions.cs†L8-L40】 Create a `MetadataLoadContext` with a resolver (for example, `PathMetadataAssemblyResolver`) to supply reference assemblies before calling `ToMetadataAssembly`.【F:test/System.Reflection2.Tests/PersistedAssemblyBuilderTests.cs†L193-L217】【F:src/System.Reflection2/System/Reflection2/PathMetadataAssemblyResolver.cs†L17-L67】 When invocation is required, attach a bridge such as `RuntimeReflectionBridge` to `MetadataLoadContext.RuntimeBridge` and map metadata types back to their runtime counterparts; binder conversions and culture-specific coercions flow across this bridge so custom `Binder` implementations can participate in argument conversion or overload resolution.【F:test/System.Reflection2.Tests/PersistedAssemblyBuilderTests.cs†L126-L174】【F:src/System.Reflection2/System/Reflection2/RuntimeReflectionBridge.cs†L12-L199】

### Unsupported scenarios

- Runtime handles (`TypeHandle`, `MethodHandle`, etc.) remain unavailable in metadata-only mode; callers must use a runtime bridge if handles or invocation are required.【F:src/System.Reflection2/System/Reflection2/MetadataMethodInfo.cs†L69-L134】【F:src/System.Reflection2/System/Reflection2/MetadataFieldInfo.cs†L31-L74】
- Materializing attribute instances is intentionally unsupported; only `CustomAttributeData` is provided even when a bridge is present.【F:src/System.Reflection2/System/Reflection2/MetadataType.cs†L136-L152】【F:src/System.Reflection2/System/Reflection2/MetadataMethodInfo.cs†L73-L120】
- Advanced runtime behaviors such as `Type.MakeGenericType` over open generic parameters with missing context, custom modifiers, and reflection emit execution helpers are still on the roadmap and may require additional shims before parity with the runtime stack.【F:src/System.Reflection2/System/Reflection2/MetadataSignatureTypeProvider.cs†L12-L131】【F:src/System.Reflection2/System/Reflection2/MetadataFunctionPointerType.cs†L1-L143】
