# System.Reflection2

System.Reflection2 provides a metadata-only layer that mirrors the public surface of the most common reflection types so Raven's compiler can reason about assemblies without loading them into the runtime. `MetadataLoadContext` owns the cache of metadata-backed assemblies, while `MetadataAssembly` and `MetadataModule` expose the familiar `Assembly`/`Module` APIs over `MetadataReader` instances.【F:src/System.Reflection2/System/Reflection2/MetadataLoadContext.cs†L8-L115】【F:src/System.Reflection2/System/Reflection2/MetadataAssembly.cs†L9-L88】

## Core building blocks

- **MetadataLoadContext** – registers assemblies from `MetadataReader` or `MetadataReaderProvider` instances and resolves dependencies through an `IMetadataAssemblyResolver` implementation.【F:src/System.Reflection2/System/Reflection2/MetadataLoadContext.cs†L23-L91】  Use `RegisterAssembly` when you already hold a reader, or hand it a `MetadataResolutionResult` produced by a resolver to keep the provider alive for the load context.
- **MetadataAssembly / MetadataModule** – surface a metadata-backed `Assembly` that exposes modules and types without JIT-loading code, and delegate type resolution back through the load context for cross-assembly references.【F:src/System.Reflection2/System/Reflection2/MetadataAssembly.cs†L20-L63】【F:src/System.Reflection2/System/Reflection2/MetadataModule.cs†L10-L84】  `MetadataModule` also fabricates constructed array, pointer, by-ref, and generic types on demand so symbol analysis can operate on closed type shapes.【F:src/System.Reflection2/System/Reflection2/MetadataModule.cs†L15-L89】
- **MetadataType/Method/Property/Field** – provide reflection objects backed purely by metadata tables. They supply names, signatures, members, and generic construction logic required by the symbol layer, while deliberately omitting runtime-only behaviors such as invocation.【F:src/System.Reflection2/System/Reflection2/MetadataType.cs†L11-L378】【F:src/System.Reflection2/System/Reflection2/MetadataMethodInfo.cs†L11-L187】【F:src/System.Reflection2/System/Reflection2/MetadataPropertyInfo.cs†L9-L156】【F:src/System.Reflection2/System/Reflection2/MetadataFieldInfo.cs†L9-L69】
- **PathMetadataAssemblyResolver** – indexes directories or individual DLLs so the load context can resolve assembly references by simple name without touching the runtime loader.【F:src/System.Reflection2/System/Reflection2/PathMetadataAssemblyResolver.cs†L10-L99】
- **PersistedAssemblyBuilderExtensions** – turns a `PersistedAssemblyBuilder` into an in-memory `MetadataAssembly`, enabling dynamic IL generation tests to interrogate the produced metadata immediately.【F:src/System.Reflection2/System/Reflection2/PersistedAssemblyBuilderExtensions.cs†L8-L40】

## How it differs from System.Reflection

System.Reflection2 intentionally implements only the metadata surface Raven needs today. Important behavioral differences from the runtime reflection stack include:

- **No runtime invocation or handles.** Attempting to invoke metadata-backed methods, constructors, properties, or fields, or to access runtime handles, throws `NotSupportedException` because the context has no backing execution environment.【F:src/System.Reflection2/System/Reflection2/MetadataMethodInfo.cs†L65-L134】【F:src/System.Reflection2/System/Reflection2/MetadataConstructorInfo.cs†L30-L54】【F:src/System.Reflection2/System/Reflection2/MetadataPropertyInfo.cs†L75-L82】【F:src/System.Reflection2/System/Reflection2/MetadataFieldInfo.cs†L31-L62】
- **Custom attributes are not materialized.** Attribute queries on types, members, or parameters all return empty collections today, so consumers must not rely on attribute inspection until a metadata reader is wired up.【F:src/System.Reflection2/System/Reflection2/MetadataType.cs†L136-L143】【F:src/System.Reflection2/System/Reflection2/MetadataMethodInfo.cs†L83-L87】【F:src/System.Reflection2/System/Reflection2/MetadataPropertyInfo.cs†L53-L57】【F:src/System.Reflection2/System/Reflection2/MetadataFieldInfo.cs†L41-L45】【F:src/System.Reflection2/System/Reflection2/MetadataParameterInfo.cs†L33-L37】
- **Events, interface maps, and some type-shape APIs are stubbed.** Event enumeration returns nothing, and operations such as `GetInterfaceMap`, `GetElementType`, or `GetArrayRank` throw for metadata types because the corresponding metadata decoding has not been implemented yet.【F:src/System.Reflection2/System/Reflection2/MetadataType.cs†L150-L293】
- **Signature support is focused on the needs of the compiler.** The signature provider currently rejects function-pointer signatures and requires pre-supplied generic context arrays when decoding open generic parameters.【F:src/System.Reflection2/System/Reflection2/MetadataSignatureTypeProvider.cs†L22-L52】 Default parameter values are also reported as `DBNull.Value` placeholders instead of actual literals.【F:src/System.Reflection2/System/Reflection2/MetadataParameterInfo.cs†L33-L37】

## Caveats and roadmap

To become a true drop-in replacement for runtime reflection in the symbol layer, System.Reflection2 still needs:

1. **Attribute materialization** – decode custom attributes from metadata blobs across assemblies, types, members, and parameters instead of returning empty arrays.【F:src/System.Reflection2/System/Reflection2/MetadataType.cs†L136-L143】【F:src/System.Reflection2/System/Reflection2/MetadataMethodInfo.cs†L83-L87】
2. **Full member surface coverage** – implement event metadata, interface maps, element-type queries, and array rank reporting so APIs like Roslyn's symbol display can rely on parity with `System.Reflection` types.【F:src/System.Reflection2/System/Reflection2/MetadataType.cs†L150-L247】【F:src/System.Reflection2/System/Reflection2/MetadataType.cs†L293-L358】
3. **Signature completeness** – add decoding for function pointers, generic parameter fallbacks, and real default parameter values to handle modern C# signatures and interop scenarios.【F:src/System.Reflection2/System/Reflection2/MetadataSignatureTypeProvider.cs†L28-L52】【F:src/System.Reflection2/System/Reflection2/MetadataParameterInfo.cs†L33-L37】
4. **Optional runtime bridges** – if callers require invocation or runtime handles, additional shims would be needed to project metadata onto lightweight runtime stubs or to plug into a reflection execution layer.【F:src/System.Reflection2/System/Reflection2/MetadataMethodInfo.cs†L65-L134】【F:src/System.Reflection2/System/Reflection2/MetadataFieldInfo.cs†L31-L62】

## Usage

The unit tests demonstrate the intended flow: build a dynamic assembly with `PersistedAssemblyBuilder`, convert it to a `MetadataAssembly`, and query the resulting metadata types just like runtime reflection, including generic instantiation and array/by-ref construction.【F:test/System.Reflection2.Tests/PersistedAssemblyBuilderTests.cs†L12-L189】【F:src/System.Reflection2/System/Reflection2/PersistedAssemblyBuilderExtensions.cs†L8-L40】 Create a `MetadataLoadContext` with a resolver (for example, `PathMetadataAssemblyResolver`) to supply reference assemblies before calling `ToMetadataAssembly`.【F:test/System.Reflection2.Tests/PersistedAssemblyBuilderTests.cs†L193-L217】【F:src/System.Reflection2/System/Reflection2/PathMetadataAssemblyResolver.cs†L17-L67】
