(* Raven language EBNF grammar
   This grammar captures the structural form of Raven source code.
   Contextual rules and parsing details are described in the language specification.
   NOTE: Non-normative. Context-sensitive parsing and validation live outside this EBNF. *)

CompilationUnit          ::= {ImportDirective} {AliasDirective} {Declaration | Statement} EOF ;

ImportDirective          ::= 'import' QualifiedName ('.' '*')? ; (* Namespace imports require '.*'; applying '.*' to a type imports its static members and nested types *)
AliasDirective           ::= 'alias' Identifier '=' Type ; (* Target may be a fully qualified name, type expression, literal type, or predefined type: bool | byte | char | decimal | double | float | int | long | nint | nuint | object | sbyte | short | string | uint | ulong | unit | ushort | '()' *)

(* ---------- Modifiers ---------- *)

MemberModifiers          ::= { MemberModifier } ;
MemberModifier           ::= AccessModifier
                           | 'static' | 'abstract' | 'virtual' | 'override' | 'final' | 'sealed' | 'new'
                           | 'readonly' | 'required'
                           | 'async' | 'extern' ;

AccessModifier           ::= 'public' | 'internal' | 'protected' | 'private' ;

AccessorModifier         ::= AccessModifier | 'async' | 'ref' | 'out' | 'in' ;

TypeModifiers            ::= { TypeModifier } ;
TypeModifier             ::= AccessModifier | 'abstract' | 'sealed' | 'open' | 'partial' | 'static' ;

FunctionModifiers        ::= { FunctionModifier } ;
FunctionModifier         ::= AccessModifier | 'async' | 'extern' | 'static' ;

(* ---------- Declarations ---------- *)

Declaration              ::= NamespaceDeclaration
                           | FunctionDeclaration
                           | ExtensionDeclaration
                           | EnumDeclaration
                           | UnionDeclaration
                           | ClassDeclaration
                           | StructDeclaration
                           | InterfaceDeclaration
                           | DelegateDeclaration ;

NamespaceDeclaration     ::= 'namespace' Identifier '{' {ImportDirective} {AliasDirective} {Declaration | Statement} '}' ;

FunctionDeclaration      ::= {AttributeList}
                             FunctionModifiers?
                             'func' Identifier TypeParameterList?
                             '(' ParameterList? ')'
                             ReturnTypeClause?
                             WhereClauseList?
                             ( Block | '=>' Expression ) ;

ExtensionKeyword         ::= 'extension' | 'trait'

(* The extension/trait identifier is optional. When omitted, the compiler synthesizes an internal name (e.g., via mangling) and the declaration cannot be referenced by name. *)
(* Unnamed extensions are intended for local/assembly-private augmentation; public APIs should use a stable explicit name. *)
ExtensionDeclaration     ::= ExtensionKeyword Identifier? TypeParameterList?
                             'for' Type
                             WhereClauseList?
                             ExtensionBody ;

ExtensionBody            ::= '{' {ExtensionMember} '}' ;
ExtensionMember          ::= ExtensionMethodDeclaration
                           | ExtensionPropertyDeclaration
                           | OperatorDeclaration
                           | ConversionOperatorDeclaration ;

ExtensionMethodDeclaration
                           ::= ExtensionMethodModifiers?
                               Identifier TypeParameterList?
                               '(' ParameterList? ')'
                               ReturnTypeClause?
                               WhereClauseList?
                               ( Block | '=>' Expression ) ;

ExtensionMethodModifiers ::= AccessModifier ;

ExtensionPropertyDeclaration
                           ::= ExtensionPropertyModifiers?
                               Identifier ':' Type AccessorList ;

ExtensionPropertyModifiers ::= AccessModifier ;

ReturnTypeClause         ::= '->' Type ;

ParameterList            ::= Parameter {',' Parameter} ;
Parameter                ::= {AttributeList} RefKindModifier? Identifier ':' Type ['=' Expression] ;
RefKindModifier          ::= 'ref' | 'out' | 'in' ;

AttributeList            ::= '[' Attribute {',' Attribute} ']' ;
Attribute                ::= QualifiedName [AttributeArgumentList] ;

EnumDeclaration          ::= TypeModifiers?
                             'enum' Identifier EnumBaseList?
                             '{' EnumMembers? '}' ;

EnumBaseList             ::= ':' Type ;
EnumMembers              ::= EnumMember {',' EnumMember} [','] ;
EnumMember               ::= Identifier ['=' Expression] ;

ClassDeclaration         ::= TypeModifiers? 'class' Identifier TypeParameterList?
                             PrimaryConstructor? BaseList?
                             WhereClauseList? PermitsClause?
                             ClassBody? ;

RecordDeclaration        ::= TypeModifiers? 'record' ['class' | 'struct'] Identifier TypeParameterList?
                             BaseList? PrimaryConstructor?
                             WhereClauseList? PermitsClause?
                             ClassBody? ;

PermitsClause            ::= 'permits' Type {',' Type} ;

PrimaryConstructor       ::= '(' ParameterList? ')' ;

StructDeclaration        ::= TypeModifiers? 'struct' Identifier TypeParameterList?
                             BaseList?
                             WhereClauseList?
                             ClassBody? ;

InterfaceDeclaration     ::= TypeModifiers? 'interface' Identifier TypeParameterList?
                             BaseList?
                             WhereClauseList?
                             ClassBody? ;

UnionDeclaration         ::= TypeModifiers? 'union' Identifier TypeParameterList?
                             WhereClauseList?
                             '{' UnionCaseList '}' TypeTerminator? ;

DelegateDeclaration      ::= TypeModifiers? 'delegate' Identifier TypeParameterList?
                             '(' ParameterList? ')'
                             ReturnTypeClause?
                             WhereClauseList?
                             TypeTerminator? ;

UnionCaseList            ::= UnionCaseClause {UnionCaseClause} ;
UnionCaseClause          ::= Identifier ParameterList? ;
(* Case-construction surface forms are semantically equivalent:
     Ok(2)
     Ok<int>(2)
     Result<int, E>.Ok(2)
     .Ok(2)                    (target-typed member binding)
   Unqualified `Ok` forms are valid only when case resolution is unambiguous;
   otherwise qualification (or an alias) is required.
   Resolution of `.Ok` / `Result.Ok` is performed by the binder against the
   union's declared case set. *)

BaseList                 ::= ':' Type {',' Type} ;

ClassBody                ::= '{' {ClassMember} '}' ;

TypeTerminator           ::= NewLineToken | ';' ;
NewLineToken             ::= /* newline trivia promoted to a token after type declarations */ ;

ClassMember              ::= FieldDeclaration
                           | MethodDeclaration
                           | ConversionOperatorDeclaration
                           | OperatorDeclaration
                           | InvocationOperatorDeclaration
                           | ConstructorDeclaration
                           | EventDeclaration
                           | PropertyDeclaration
                           | IndexerDeclaration
                           | DelegateDeclaration ;

FieldDeclaration         ::= MemberModifiers? FieldKind VariableDeclarators ';' ;  (* `required` is a MemberModifier *)
FieldKind                ::= 'let' | 'val' | 'var' | 'const' ;

VariableDeclarators      ::= VariableDeclarator {',' VariableDeclarator} ;
VariableDeclarator       ::= Identifier (':' Type)? ['=' Expression] ;

ConstructorDeclaration   ::= MemberModifiers?
                             'init' Identifier? '(' ParameterList? ')'
                             ( Block | '=>' Expression ) ;

MethodDeclaration        ::= MemberModifiers?
                             ExplicitInterfaceSpecifier?
                             Identifier TypeParameterList?
                             '(' ParameterList? ')'
                             ReturnTypeClause?
                             WhereClauseList?
                             ( Block | '=>' Expression ) ;

ConversionOperatorDeclaration
                         ::= MemberModifiers?
                             ( 'explicit' | 'implicit' ) 'operator' TypeParameterList?
                             '(' ParameterList? ')'
                             ReturnTypeClause?
                             WhereClauseList?
                             ( Block | '=>' Expression ) ;

OperatorDeclaration      ::= MemberModifiers?
                             'operator' OverloadableOperator TypeParameterList?
                             '(' ParameterList? ')'
                             ReturnTypeClause?
                             WhereClauseList?
                             ( Block | '=>' Expression ) ;

OverloadableOperator     ::= '+' | '-' | '*' | '/' | '%' | '^' | '&' | '&&' | 'and'
                           | '|' | '||' | 'or' | '==' | '!=' | '<' | '<=' | '>'
                           | '>=' | '!' | '++' | '--' ;

ExplicitInterfaceSpecifier ::= Type '.' ;

InvocationOperatorDeclaration
                           ::= MemberModifiers?
                               'self' TypeParameterList?
                               '(' ParameterList? ')'
                               ReturnTypeClause?
                               WhereClauseList?
                               ( Block | '=>' Expression ) ;

PropertyDeclaration      ::= MemberModifiers?
                             ExplicitInterfaceSpecifier? Identifier ':' Type AccessorList ;  (* `required` is a MemberModifier *)

IndexerDeclaration       ::= MemberModifiers?
                             ExplicitInterfaceSpecifier? Identifier BracketedParameterList ':' Type AccessorList ;

EventDeclaration         ::= MemberModifiers?
                             ExplicitInterfaceSpecifier? 'event' Identifier ':' Type ( EventAccessorList | ';' ) ;

AccessorList             ::= '{' Accessor {Accessor} '}' ;
Accessor                 ::= AccessorModifier? ('get' | 'set' | 'init')
                             ( Block | '=>' Expression | ';' ) ;

EventAccessorList        ::= '{' EventAccessor {EventAccessor} '}' ;
EventAccessor            ::= AccessorModifier? ('add' | 'remove')
                             ( Block | '=>' Expression | ';' ) ;

BracketedParameterList   ::= '[' ParameterList? ']' ;

(* ---------- Generics & constraints ---------- *)

TypeParameterList        ::= '<' TypeParameter {',' TypeParameter} '>' ;

TypeParameter            ::= Variance? Identifier InlineConstraints? ;

InlineConstraints        ::= ':' TypeParameterConstraintList ;

Variance                 ::= 'out' | 'in' ;

WhereClauseList          ::= WhereClause { WhereClause } ;

WhereClause              ::= 'where' Identifier ':' TypeParameterConstraintList ;

TypeParameterConstraintList
                         ::= TypeParameterConstraint {',' TypeParameterConstraint} ;

TypeParameterConstraint  ::= 'class'            (* reference type constraint *)
                           | 'struct'           (* value type constraint *)
                           | 'notnull'          (* non-null constraint *)
                           | 'unmanaged'        (* unmanaged constraint *)
                           | 'new' '(' ')'      (* public parameterless ctor *)
                           | Type ;             (* base class / interface constraint *)

(* ---------- Statements ---------- *)

(* Newline tokens act as implicit statement terminators unless the parser is
   in a continuation context that still requires more of the current
   expression—such as immediately after '=' or a binary operator. In those
   cases the newline is preserved as trivia on the next token instead of
   ending the statement. Other terminators, including ';', '}', and keywords
   like 'else' that conclude the enclosing construct, serve the same role when
   they appear. *)

Statement                ::= LocalDeclaration
                           | ReturnStatement
                           | ThrowStatement
                           | BreakStatement
                           | ContinueStatement
                           | FunctionStatement
                           | IfStatement
                           | WhileStatement
                           | ForStatement
                           | TryStatement
                           | AssignmentStatement
                           | ExpressionStatement ;

LocalDeclaration         ::= ('let' | 'val' | 'var' | 'const') LocalVariableDeclarators ;
LocalVariableDeclarators ::= LocalVariableDeclarator {',' LocalVariableDeclarator} ;
LocalVariableDeclarator  ::= Identifier (':' Type)? '=' Expression ;

ReturnStatement          ::= 'return' Expression? ;
ThrowStatement           ::= 'throw' Expression ;
BreakStatement           ::= 'break' ;
ContinueStatement        ::= 'continue' ;

FunctionStatement        ::= {AttributeList}
                             ('async' | 'unsafe' | 'extern')*
                             'func' Identifier TypeParameterList?
                             '(' ParameterList? ')'
                             ReturnTypeClause?
                             WhereClauseList?
                             Block ;

ExpressionStatement      ::= Expression ;

IfStatement              ::= 'if' Expression Statement ['else' Statement] ;

(* NOTE: In statement headers, the following '{' begins the statement body and is not parsed as an ObjectInitializer trailer.
   This disambiguation is performed by the parser (context-sensitive), not by this EBNF. *)
WhileStatement           ::= 'while' Expression Statement ;
ForStatement             ::= 'for' 'each'? ForIterationVariable? 'in' Expression Statement ;
ForIterationVariable     ::= Identifier | '_' ;

TryStatement             ::= 'try' Block (CatchClauseList [FinallyClause] | FinallyClause) ;
CatchClauseList          ::= CatchClause {CatchClause} ;
CatchClause              ::= 'catch' CatchDeclaration? Block ;
CatchDeclaration         ::= '(' Type [Identifier] ')' ;
FinallyClause            ::= 'finally' Block ;

(* Keep statement assignments consistent with expression assignments:
   - LHS must be assignable OR a deconstruction designation.
   - Patterns are NOT assignment targets. *)
AssignmentStatement      ::= Assignable AssignmentOperator Expression
                           | DeconstructionAssignmentStatement ;

DeconstructionAssignmentStatement
                         ::= VariableDesignation AssignmentOperator Expression ;

(* ---------- Expressions & precedence (lowest → highest) ---------- *)

Expression               ::= AssignmentExpression {MatchExpressionSuffix} ;

MatchExpressionSuffix    ::= 'match' '{' MatchArmList '}' ;
MatchArmList             ::= MatchArm {MatchArm} ;
MatchArm                 ::= Pattern MatchGuardClause? '=>' Expression MatchArmTerminator? ;
MatchGuardClause         ::= 'when' Expression ;
MatchArmTerminator       ::= NewLineToken | ';' ;

AssignmentExpression     ::= Assignable AssignmentOperator AssignmentExpression
                           | DeconstructionAssignment
                           | ConditionalNullCoalesceExpression ;

DeconstructionAssignment ::= VariableDesignation AssignmentOperator AssignmentExpression ;

AssignmentOperator       ::= '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '??=' ;

Assignable               ::= Identifier
                           | MemberAccessExpression
                           | MemberBindingExpression
                           | ElementAccessExpression ;

(* ---------- Patterns ---------- *)

Pattern                  ::= OrPattern ;

OrPattern                ::= AndPattern {'or' AndPattern} ;
AndPattern               ::= UnaryPattern {'and' UnaryPattern} ;
UnaryPattern             ::= 'not' UnaryPattern | PrimaryPattern ;

PrimaryPattern           ::= ParenthesizedPattern
                           | RelationalPattern
                           | ConstantPattern
                           | VariablePattern
                           | DeclarationPattern
                           | PositionalPattern
                           | CollectionPattern
                           | DiscardPattern
                           | MemberPattern
                           | RecordPattern
                           | PropertyPattern ;

ConstantPattern          ::= Literal | ConstantPatternOperand ;

ConstantPatternOperand    ::= Identifier ;

(* A bare identifier in pattern position never introduces a binding.
   Bindings require an explicit BindingKeyword (let/val/var).

   A bare identifier is context-sensitive:
   - If the scrutinee is a discriminated union and the identifier matches a case name
     in the union's declared case set, it is treated as a DU case pattern.
   - If it binds to an in-scope value, it is a value/constant pattern (matches by equality).
   - Otherwise it is interpreted as a type name and forms a DeclarationPattern.
   This disambiguation is performed by the binder. *)
   
BindingKeyword           ::= 'let' | 'val' | 'var' ;

VariablePattern          ::= BindingKeyword VariableDesignation ;

(* NOTE: A single Identifier can be parsed as either ConstantPatternOperand or as the `Type` in a
   DeclarationPattern. The binder resolves the ambiguity by preferring a value/constant pattern
   when the identifier resolves to a value symbol in scope; otherwise it is treated as a type. *)
DeclarationPattern       ::= Type [VariableDesignation] ;

PositionalPattern        ::= '(' PatternElement ',' PatternElement {',' PatternElement} ')' ;
PatternElement           ::= [PositionalPatternElementDesignation] Pattern ;

CollectionPattern        ::= '[' PatternList? ']' ;

(* Positional element designations introduce a new binding for the element.
   To avoid ambiguity with value/constant patterns, the binding keyword is required.
   For example: (val a: bool, _) is permitted, but (a: bool, _) is an error. *)
PositionalPatternElementDesignation
                         ::= BindingKeyword Identifier ':' ;

DiscardPattern           ::= '_' | Type '_' ;

MemberPattern            ::= MemberPath [ '(' PatternList? ')' ] ;
MemberPath               ::= '.' Identifier
                           | Type '.' Identifier ;

PatternList              ::= Pattern {',' Pattern} ;

RecordPattern            ::= Type '(' PatternList? ')' ;
(* Binder note: when Type resolves to a discriminated-union case name for the
   current scrutinee, this form is interpreted as a DU case deconstruction
   pattern rather than a regular record pattern. *)

PropertyPattern          ::= Type? '{' PropertySubpatternList? '}' PropertyPatternDesignation? ;
PropertySubpatternList   ::= PropertySubpattern {',' PropertySubpattern} ;
PropertySubpattern       ::= Identifier ':' Pattern ;

PropertyPatternDesignation
                         ::= VariableDesignation
                           | '_' ;

ParenthesizedPattern     ::= '(' Pattern ')' ;

RelationalPattern        ::= RelationalOperator RelationalPatternOperand ;
RelationalOperator       ::= '<' | '<=' | '>' | '>=' | '==' | '!=' ;
RelationalPatternOperand ::= Expression ; (* binder should enforce “constant-ish” rules *)

VariableDesignation      ::= VariableDesignationCore [':' Type] ; (* In patterns, a single-variable designation always requires an explicit BindingKeyword (let/val/var), including when a type annotation is present. *)
VariableDesignationCore  ::= SingleVariableDesignation | ParenthesizedVariableDesignation ;
SingleVariableDesignation ::= BindingKeyword Identifier ;

ParenthesizedVariableDesignation
                         ::= '(' VariableDesignation {',' VariableDesignation} ')' ;

ConditionalNullCoalesceExpression
                         ::= LogicalOrExpression {'??' LogicalOrExpression} ;

LogicalOrExpression      ::= LogicalAndExpression {'||' LogicalAndExpression} ;
LogicalAndExpression     ::= BitwiseOrExpression {'&&' BitwiseOrExpression} ;
BitwiseOrExpression      ::= BitwiseXorExpression {'|' BitwiseXorExpression} ;
BitwiseXorExpression     ::= BitwiseAndExpression {'^' BitwiseAndExpression} ;
BitwiseAndExpression     ::= EqualityExpression {'&' EqualityExpression} ;
EqualityExpression       ::= RelationalExpression {('==' | '!=') RelationalExpression} ;
RelationalExpression     ::= TypeTestExpression
                             {('<' | '>' | '<=' | '>=') TypeTestExpression} ;

TypeTestExpression       ::= RangeExpression { 'as' Type } [ 'is' Pattern ] ;

RangeExpression          ::= RangeStart '..' RangeEnd
                           | ShiftExpression ;

RangeStart               ::= RangeIndex? ;
RangeEnd                 ::= RangeIndex? ;

RangeIndex               ::= '^'? AdditiveExpression ;

ShiftExpression          ::= AdditiveExpression {('<<' | '>>') AdditiveExpression} ;

AdditiveExpression       ::= MultiplicativeExpression {('+' | '-') MultiplicativeExpression} ;
MultiplicativeExpression ::= UnaryExpression {('*' | '/' | '%') UnaryExpression} ;

UnaryExpression          ::= LambdaExpression
                           | PostfixExpression
                           | ('+' | '-' | '!') UnaryExpression
                           | 'await' UnaryExpression
                           | CastExpression ;

LambdaExpression         ::= 'async'? LambdaParameterClause ReturnTypeClause? '=>' Expression ;
LambdaParameterClause    ::= '(' ParameterList? ')' | Parameter ;

CastExpression           ::= '(' Type ')' UnaryExpression ;

PostfixExpression        ::= PrimaryExpression { PostfixTrailer } ;

PostfixTrailer           ::= ArgumentList
                           | MemberAccessTrailer
                           | ElementAccessTrailer
                           | PropagateTrailer
                           | ConditionalAccessTrailer
                           | ObjectInitializer
                           | WithExpression ;

ArgumentList             ::= '(' [Argument {',' Argument}] ')' ;
Argument                 ::= [Identifier ':'] Expression ;
AttributeArgumentList    ::= '(' [AttributeArgument {',' AttributeArgument}] ')' ;
AttributeArgument        ::= [Identifier ':'] Expression ; (* Attribute named arguments must use ':'; '=' is not valid syntax. *)

MemberAccessTrailer      ::= '.' Identifier ;
ElementAccessTrailer     ::= '[' Expression ']' ;

(* `?` is context-sensitive in postfix position:
   - If followed by `.`, `(`, or `[`, it forms conditional access: `?.`, `?(`, `?[`.
   - Otherwise it is the Result-propagation postfix operator: `<expr>?`. *)
PropagateTrailer          ::= '?' ;
ConditionalAccessTrailer ::= '?' (MemberAccessTrailer | ElementAccessTrailer | ArgumentList) ;

(* ---------- Object initializers (SwiftUI/Flutter-style) ---------- *)

(* ObjectInitializer is parsed as a postfix trailer, enabling:
     - Window { ... }
     - Window() { ... }
     - items.Where(...) { ... }  (disallowed in statement headers by the parser; see note below)

   Entries may freely mix property assignments and child/content expressions. *)

ObjectInitializer         ::= '{' { ObjectInitializerEntry } '}' ;

ObjectInitializerEntry    ::= ObjectInitializerAssignmentEntry
                            | ObjectInitializerExpressionEntry ;

ObjectInitializerAssignmentEntry
                           ::= Identifier '=' Expression ObjectInitializerTerminator? ;

ObjectInitializerExpressionEntry
                           ::= Expression ObjectInitializerTerminator? ;

(* Terminators are context-sensitive in Raven; commas are permitted but not required when a newline ends the entry. *)
ObjectInitializerTerminator
                           ::= ',' | NewLineToken | ';' ;

(* ---------- With expressions ---------- *)

WithExpression           ::= 'with' '{' { WithAssignment } '}' ;

WithAssignment           ::= Identifier '=' Expression WithAssignmentTerminator? ;

WithAssignmentTerminator ::= ',' | NewLineToken | ';' ;
MemberBindingExpression  ::= '.' Identifier ;
(* Member binding is target-typed; for discriminated unions, `.Case(...)` binds
   to a case on the expected union type. *)

(* ---------- Primaries ----------
   NOTE: Block and IfExpression can appear as expressions.
         While and for constructs exist only as statements. *)

PrimaryExpression        ::= Literal
                           | DefaultExpression
                           | TypeOfExpression
                           | NameOfExpression
                           | Identifier
                           | MemberBindingExpression
                           | ObjectCreationExpression
                           | TupleExpression
                           | ParenthesizedExpression
                           | TryExpression
                           | ReturnExpression
                           | ThrowExpression
                           | Block
                           | IfExpression
                           | InterpolatedStringExpression ;

DefaultExpression        ::= 'default' | 'default' '(' Type ')' ;

TypeOfExpression         ::= 'typeof' '(' Type ')' ;
NameOfExpression         ::= 'nameof' '(' NameOfOperand ')' ;

(* `nameof` is a compile-time-only expression that produces the unqualified name of the referenced symbol.
   The operand is syntactic and is validated by the binder. *)
NameOfOperand            ::= Identifier
                           | MemberAccessExpression
                           | MemberBindingExpression
                           | QualifiedName ;

TryExpression            ::= 'try' ['?'] Expression ;
ReturnExpression         ::= 'return' Expression ;
ThrowExpression          ::= 'throw' Expression ;

Block                    ::= '{' {Statement} '}' ;

IfExpression             ::= 'if' Expression Expression 'else' Expression ;

InterpolatedStringExpression
                         ::= '"' {InterpolatedStringContent} '"' ;
InterpolatedStringContent ::= InterpolatedStringText | Interpolation ;
InterpolatedStringText   ::= /* text segment without ${ or closing quote */ ;
Interpolation            ::= '${' Expression '}' ;

ObjectCreationExpression ::= 'new' Type ArgumentList ObjectInitializer? ;

TupleExpression          ::= '(' TupleElement {',' TupleElement} ')' ;
TupleElement             ::= [Identifier ':'] Expression ;

ParenthesizedExpression  ::= '(' Expression ')' ;

Literal                  ::= NumericLiteral
                           | StringLiteral
                           | MultilineStringLiteral
                           | 'true' | 'false' | 'null' ;

(* ---------- Types ---------- *)

Type                     ::= ByRefType | PointerType | UnionType ;

ByRefType                ::= '&' Type ;
PointerType              ::= '*' Type ;

UnionType                ::= FunctionType {'|' FunctionType} ; (* left-assoc *)

FunctionType             ::= FunctionParameterClause '->' Type
                           | NullableType ;

FunctionParameterClause  ::= FunctionTypeParameterList | NullableType ;

FunctionTypeParameterList
                         ::= '(' [Type {',' Type}] ')' ;

NullableType             ::= PrimaryType ['?'] ;

PrimaryType              ::= TupleType
                           | GenericType
                           | SimpleType
                           | NullType
                           | ParenthesizedType ;

NullType                 ::= 'null' ;

SimpleType               ::= BuiltinType | QualifiedName ;
BuiltinType              ::= 'bool'
                           | 'char'
                           | 'sbyte'
                           | 'byte'
                           | 'short'
                           | 'ushort'
                           | 'int'
                           | 'uint'
                           | 'long'
                           | 'ulong'
                           | 'nint'
                           | 'nuint'
                           | 'float'
                           | 'double'
                           | 'decimal'
                           | 'string'
                           | 'object'
                           | 'unit'
                           | '(' ')' ;

GenericType              ::= QualifiedName '<' TypeList '>' ;
TypeList                 ::= Type {',' Type} ;

TupleType                ::= '(' TupleTypeElement {',' TupleTypeElement} ')' ;
TupleTypeElement         ::= [Identifier ':'] Type ;

ParenthesizedType        ::= '(' Type ')' ;

QualifiedName            ::= Identifier {'.' Identifier} ;
(* `Union.Case` is parsed as a QualifiedName/member chain and may be rebound by
   semantics as a discriminated-union case reference. *)

Identifier               ::= /* ASCII letter, '_' or '$' followed by letters, digits, '_' or '$'.
                               The single '_' token is reserved for discards. */ ;


StringLiteral            ::= '"' {InterpolatedStringText | Interpolation} '"' ;
InterpolatedStringText   ::= /* content with escapes */ ;
Interpolation            ::= '$' Identifier | '$' '{' Expression '}' ;

(* Multiline string literals are triple-quoted strings that may span multiple lines.
   They are raw (no escape-sequence decoding). Interpolation is permitted using the same
   forms as regular strings: `$Identifier` and `${ Expression }`.

   NOTE: Non-normative. The lexer produces the triple-quoted literal as a single token;
   the parser/binder interpret interpolation within its raw text. *)
MultilineStringLiteral        ::= '"""' {MultilineInterpolatedContent} '"""' ;
MultilineInterpolatedContent  ::= MultilineInterpolatedText | Interpolation ;
MultilineInterpolatedText     ::= /* raw text segment; may include newlines; stops before an interpolation start or closing delimiter */ ;

(* ---------- Numeric literals (lexical forms) ---------- *)

(* Numeric literals are lexically resolved by the lexer. This grammar documents the allowed surface forms.

   Examples:
     1        (* integer *)
     1.0      (* decimal-point real *)
     .0       (* leading-dot real *)
     1e3      (* exponent real *)
     0xFF     (* hex integer *)
     0b1010   (* binary integer *)

   Suffixes (optional, case-insensitive):
     B  -> byte
     L  -> long
     F  -> float
     D  -> double
     M  -> decimal

   If no suffix is present, the default type is determined by the lexer:
     - integer literals default to int (or a wider integral type if specified/required by the binder)
     - real literals default to double
*)

NumericLiteral           ::= IntegerLiteral NumericSuffix?
                           | RealLiteral NumericSuffix? ;

NumericSuffix            ::=  'b' | 'B'
                           | 'l' | 'L'
                           | 'f' | 'F'
                           | 'd' | 'D'
                           | 'm' | 'M' ;

IntegerLiteral           ::= DecimalIntegerLiteral
                           | HexIntegerLiteral
                           | BinaryIntegerLiteral ;

DecimalIntegerLiteral    ::= DecimalDigits ;
HexIntegerLiteral        ::= '0' ('x' | 'X') HexDigits ;
BinaryIntegerLiteral     ::= '0' ('b' | 'B') BinaryDigits ;

(* Real literals support:
   - a decimal point: 1.0, 1., .0
   - an exponent: 1e3, 1.0e-3, .5E+2
   A real literal must contain either a '.' or an exponent part (or both). *)
RealLiteral              ::= RealWithDot ExponentPart?
                           | DecimalDigits ExponentPart ;

RealWithDot              ::= DecimalDigits '.' DecimalDigits?
                           | '.' DecimalDigits ;

ExponentPart             ::= ('e' | 'E') Sign? DecimalDigits ;
Sign                     ::= '+' | '-' ;

DecimalDigits            ::= DecimalDigit { DecimalDigit | '_' } ;
HexDigits                ::= HexDigit { HexDigit | '_' } ;
BinaryDigits             ::= BinaryDigit { BinaryDigit | '_' } ;

DecimalDigit             ::= '0'..'9' ;
HexDigit                 ::= DecimalDigit | 'a'..'f' | 'A'..'F' ;
BinaryDigit              ::= '0' | '1' ;
