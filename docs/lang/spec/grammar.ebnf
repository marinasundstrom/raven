(* Raven language EBNF grammar
   This grammar captures the structural form of Raven source code.
   Contextual rules and parsing details are described in the language specification.
   NOTE: Non-normative. Context-sensitive parsing and validation live outside this EBNF. *)

CompilationUnit          ::= {ImportDirective} {AliasDirective} {Declaration | Statement} EOF ;

ImportDirective          ::= 'import' QualifiedName ('.' '*')? ; (* Namespace imports require '.*'; applying '.*' to a type imports its static members and nested types *)
AliasDirective           ::= 'alias' Identifier '=' Type ; (* Target may be a fully qualified name, type expression, literal type, or predefined type: bool | char | int | string | unit | '()' *)

(* ---------- Modifiers ---------- *)

MemberModifiers          ::= { MemberModifier } ;
MemberModifier           ::= AccessModifier
                           | 'static' | 'abstract' | 'virtual' | 'override' | 'sealed'
                           | 'readonly' | 'async' | 'extern' ;

AccessModifier           ::= 'public' | 'internal' | 'protected' | 'private' ;

AccessorModifier         ::= AccessModifier | 'async' | 'ref' | 'out' | 'in' ;

TypeModifiers            ::= { TypeModifier } ;
TypeModifier             ::= AccessModifier | 'abstract' | 'sealed' | 'open' | 'partial' | 'static' ;

FunctionModifiers        ::= { FunctionModifier } ;
FunctionModifier         ::= AccessModifier | 'async' | 'extern' | 'static' ;

(* ---------- Declarations ---------- *)

Declaration              ::= NamespaceDeclaration
                           | FunctionDeclaration
                           | ExtensionDeclaration
                           | EnumDeclaration
                           | UnionDeclaration
                           | ClassDeclaration
                           | StructDeclaration
                           | InterfaceDeclaration ;

NamespaceDeclaration     ::= 'namespace' Identifier '{' {ImportDirective} {AliasDirective} {Declaration | Statement} '}' ;

FunctionDeclaration      ::= FunctionModifiers?
                             'func' Identifier '(' ParameterList? ')'
                             ReturnTypeClause?
                             ( Block | '=>' Expression ) ;

ExtensionDeclaration     ::= 'extension' Identifier 'for' Type ExtensionBody ;
ExtensionBody            ::= '{' {ExtensionMember} '}' ;
ExtensionMember          ::= ExtensionMethodDeclaration
                           | ExtensionPropertyDeclaration ;
ExtensionMethodDeclaration
                           ::= ExtensionMethodModifiers?
                               Identifier '(' ParameterList? ')'
                               ReturnTypeClause?
                               ( Block | '=>' Expression ) ;
ExtensionMethodModifiers ::= AccessModifier ;
ExtensionPropertyDeclaration
                           ::= ExtensionPropertyModifiers?
                               Identifier ':' Type AccessorList ;
ExtensionPropertyModifiers ::= AccessModifier ;

ReturnTypeClause         ::= '->' Type ;

ParameterList            ::= Parameter {',' Parameter} ;
Parameter                ::= ['out'] Identifier ':' Type ['=' Expression] ;

EnumDeclaration          ::= TypeModifiers?
                             'enum' Identifier '{' EnumMembers? '}' ;
EnumMembers              ::= EnumMember {',' EnumMember} ;
EnumMember               ::= Identifier ['=' Expression] ;

ClassDeclaration         ::= TypeModifiers? 'class' Identifier PrimaryConstructor? BaseList? ClassBody ;
PrimaryConstructor       ::= '(' ParameterList? ')' ;
StructDeclaration        ::= TypeModifiers? 'struct' Identifier ClassBody ;
InterfaceDeclaration     ::= TypeModifiers? 'interface' Identifier BaseList? ClassBody ;
UnionDeclaration         ::= TypeModifiers? 'union' Identifier TypeParameterList?
                             '{' UnionCaseList '}' TypeTerminator? ;
UnionCaseList            ::= UnionCaseClause {UnionCaseClause} ;
UnionCaseClause          ::= Identifier ParameterList? ;
BaseList                 ::= ':' Type {',' Type} ;
ClassBody                ::= '{' {ClassMember} '}' ;

TypeTerminator           ::= NewLineToken | ';' ;
NewLineToken             ::= /* newline trivia promoted to a token after type declarations */ ;

ClassMember              ::= FieldDeclaration
                           | MethodDeclaration
                           | InvocationOperatorDeclaration
                           | ConstructorDeclaration
                           | PropertyDeclaration
                           | IndexerDeclaration ;

FieldDeclaration         ::= MemberModifiers? FieldKind VariableDeclarators ';' ;
FieldKind                ::= 'let' | 'var' ;

VariableDeclarators      ::= VariableDeclarator {',' VariableDeclarator} ;
VariableDeclarator       ::= Identifier (':' Type)? ['=' Expression] ;

ConstructorDeclaration   ::= MemberModifiers?
                             'init' Identifier? '(' ParameterList? ')'
                             ( Block | '=>' Expression ) ;

MethodDeclaration        ::= MemberModifiers?
                             ExplicitInterfaceSpecifier? Identifier '(' ParameterList? ')'
                             ReturnTypeClause?
                             ( Block | '=>' Expression ) ;

ExplicitInterfaceSpecifier ::= Type '.' ;

InvocationOperatorDeclaration
                           ::= MemberModifiers?
                               'self' '(' ParameterList? ')'
                               ReturnTypeClause?
                               ( Block | '=>' Expression ) ;

PropertyDeclaration      ::= MemberModifiers?
                             ExplicitInterfaceSpecifier? Identifier ':' Type AccessorList ;

IndexerDeclaration       ::= MemberModifiers?
                             ExplicitInterfaceSpecifier? Identifier BracketedParameterList ':' Type AccessorList ;

AccessorList             ::= '{' Accessor {Accessor} '}' ;
Accessor                 ::= AccessorModifier? ('get' | 'set')
                             ( Block | '=>' Expression | ';' ) ;

BracketedParameterList   ::= '[' ParameterList? ']' ;

(* ---------- Statements ---------- *)

(* Newline tokens act as implicit statement terminators unless the parser is
   in a continuation context that still requires more of the current
   expression—such as immediately after '=' or a binary operator. In those
   cases the newline is preserved as trivia on the next token instead of
   ending the statement. Other terminators, including ';', '}', and keywords
   like 'else' that conclude the enclosing construct, serve the same role when
   they appear. *)

Statement                ::= LocalDeclaration
                           | ReturnStatement
                           | ThrowStatement
                           | BreakStatement
                           | ContinueStatement
                           | FunctionStatement
                           | IfStatement
                           | WhileStatement
                           | ForStatement
                           | TryStatement
                           | AssignmentStatement
                           | ExpressionStatement ;

LocalDeclaration         ::= ('let' | 'var' | 'const') LocalVariableDeclarators ;
LocalVariableDeclarators ::= LocalVariableDeclarator {',' LocalVariableDeclarator} ;
LocalVariableDeclarator  ::= Identifier (':' Type)? '=' Expression ;

ReturnStatement          ::= 'return' Expression? ;

ThrowStatement           ::= 'throw' Expression ;

BreakStatement           ::= 'break' ;

ContinueStatement        ::= 'continue' ;

FunctionStatement        ::= 'async'? 'func' Identifier TypeParameterList? '(' ParameterList? ')' ReturnTypeClause? Block ;

AssignmentStatement      ::= AssignmentTarget AssignmentOperator Expression ;

ExpressionStatement      ::= Expression ;

IfStatement              ::= 'if' Expression Statement ['else' Statement] ;
WhileStatement           ::= 'while' Expression Statement ;
ForStatement             ::= 'for' 'each'? ForIterationVariable? 'in' Expression Statement ;
ForIterationVariable     ::= Identifier | '_' ;

TryStatement             ::= 'try' Block (CatchClauseList [FinallyClause] | FinallyClause) ;
CatchClauseList          ::= CatchClause {CatchClause} ;
CatchClause              ::= 'catch' CatchDeclaration? Block ;
CatchDeclaration         ::= '(' Type [Identifier] ')' ;
FinallyClause            ::= 'finally' Block ;

(* ---------- Expressions & precedence (lowest → highest) ---------- *)

Expression               ::= AssignmentExpression {MatchExpressionSuffix} ;

MatchExpressionSuffix    ::= 'match' '{' MatchArmList '}' ;
MatchArmList             ::= MatchArm {MatchArm} ;
MatchArm                 ::= Pattern MatchGuardClause? '=>' Expression MatchArmTerminator? ;
MatchGuardClause         ::= 'when' Expression ;
MatchArmTerminator       ::= NewLineToken | ';' ;

AssignmentExpression     ::= AssignmentTarget AssignmentOperator AssignmentExpression
                           | ConditionalNullCoalesceExpression ;

AssignmentOperator       ::= '=' | '+=' | '-=' | '*=' | '/=' | '%=' ;

AssignmentTarget         ::= Assignable | Pattern ;

Assignable               ::= Identifier
                           | MemberAccessExpression
                           | MemberBindingExpression
                           | ElementAccessExpression ;

Pattern                  ::= OrPattern ;
OrPattern                ::= AndPattern {'or' AndPattern} ;
AndPattern               ::= UnaryPattern {'and' UnaryPattern} ;
UnaryPattern             ::= 'not' UnaryPattern | PrimaryPattern ;
PrimaryPattern           ::= ConstantPattern | VariablePattern | DeclarationPattern | TuplePattern | DiscardPattern | CasePattern ;

ConstantPattern          ::= Literal ;
VariablePattern          ::= ('let' | 'var') VariableDesignation ;
DeclarationPattern       ::= Type [VariableDesignation] ;
TuplePattern             ::= '(' PatternElement {',' PatternElement} ')' ;
PatternElement           ::= [Identifier ':'] Pattern ;

DiscardPattern           ::= '_' | Type '_' ;

CasePattern              ::= CasePath [ '(' PatternList? ')' ] ;

CasePath                 ::= '.' Identifier
                           | Type '.' Identifier ;

PatternList              ::= Pattern {',' Pattern} ;

VariableDesignation      ::= VariableDesignationCore [':' Type] ;
VariableDesignationCore  ::= Identifier | ParenthesizedVariableDesignation ;
ParenthesizedVariableDesignation
                           ::= '(' VariableDesignation {',' VariableDesignation} ')' ;

ConditionalNullCoalesceExpression
                           ::= LogicalOrExpression {'??' LogicalOrExpression} ;

LogicalOrExpression      ::= LogicalAndExpression {'||' LogicalAndExpression} ;
LogicalAndExpression     ::= EqualityExpression {'&&' EqualityExpression} ;
EqualityExpression       ::= RelationalExpression {('==' | '!=') RelationalExpression} ;
RelationalExpression     ::= TypeTestExpression
                             {('<' | '>' | '<=' | '>=') TypeTestExpression} ;

TypeTestExpression       ::= AdditiveExpression {('is' | 'as') Type} ;

AdditiveExpression       ::= MultiplicativeExpression {('+' | '-') MultiplicativeExpression} ;
MultiplicativeExpression ::= UnaryExpression {('*' | '/' | '%') UnaryExpression} ;

UnaryExpression          ::= LambdaExpression
                           | PostfixExpression
                           | ('+' | '-' | '!') UnaryExpression
                           | 'await' UnaryExpression
                           | CastExpression ;

LambdaExpression         ::= 'async'? LambdaParameterClause ReturnTypeClause? '=>' Expression ;
LambdaParameterClause    ::= '(' ParameterList? ')' | Parameter ;

CastExpression           ::= '(' Type ')' UnaryExpression ;

PostfixExpression        ::= PrimaryExpression { PostfixTrailer } ;
PostfixTrailer           ::= ArgumentList
                           | MemberAccessTrailer
                           | ElementAccessTrailer
                           | ConditionalAccessTrailer ;

ArgumentList             ::= '(' [Argument {',' Argument}] ')' ;
Argument                 ::= [Identifier ':'] Expression ;

MemberAccessTrailer      ::= '.' Identifier ;
ElementAccessTrailer     ::= '[' Expression ']' ;
ConditionalAccessTrailer ::= '?' (MemberAccessTrailer | ElementAccessTrailer) ;

MemberBindingExpression  ::= '.' Identifier ;

(* ---------- Primaries ----------
   NOTE: Block and IfExpression can appear as expressions.
         While and for constructs exist only as statements. *)
PrimaryExpression        ::= Literal
                           | DefaultExpression
                           | Identifier
                           | MemberBindingExpression
                           | ObjectCreationExpression
                           | TupleExpression
                           | ParenthesizedExpression
                           | TryExpression
                           | Block
                           | IfExpression
                           | InterpolatedStringExpression ;

DefaultExpression        ::= 'default' | 'default' '(' Type ')' ;

TryExpression            ::= 'try' Expression ;

Block                    ::= '{' {Statement} '}' ;

IfExpression             ::= 'if' Expression Expression 'else' Expression ;
InterpolatedStringExpression ::= '"' {InterpolatedStringContent} '"' ;
InterpolatedStringContent ::= InterpolatedStringText | Interpolation ;
InterpolatedStringText   ::= /* text segment without ${ or closing quote */ ;
Interpolation            ::= '${' Expression '}' ;

ObjectCreationExpression ::= 'new' Type '(' [Argument {',' Argument}] ')' ;

TupleExpression          ::= '(' TupleElement {',' TupleElement} ')' ;
TupleElement             ::= [Identifier ':'] Expression ;

ParenthesizedExpression  ::= '(' Expression ')' ;

Literal                  ::= NumericLiteral
                           | StringLiteral
                           | 'true' | 'false' | 'null' ;

(* ---------- Types ---------- *)

Type                     ::= ByRefType | PointerType | UnionType ;

ByRefType                ::= '&' Type ;

PointerType              ::= '*' Type ;

UnionType                ::= FunctionType {'|' FunctionType} ;     (* left-assoc *)

FunctionType             ::= FunctionParameterClause '->' Type
                           | NullableType ;

FunctionParameterClause  ::= FunctionTypeParameterList | NullableType ;

FunctionTypeParameterList
                           ::= '(' [Type {',' Type}] ')' ;

NullableType             ::= PrimaryType ['?'] ;

PrimaryType              ::= TupleType
                           | GenericType
                           | SimpleType
                           | NullType
                           | ParenthesizedType ;

NullType                 ::= 'null' ;

SimpleType               ::= BuiltinType | QualifiedName ;
BuiltinType              ::= 'int' | 'string' | 'bool' | 'unit' | 'char' | '(' ')' ;

GenericType              ::= QualifiedName '<' TypeList '>' ;
TypeList                 ::= Type {',' Type} ;

TupleType                ::= '(' TupleTypeElement {',' TupleTypeElement} ')' ;
TupleTypeElement         ::= [Identifier ':'] Type ;
ParenthesizedType        ::= '(' Type ')' ;

QualifiedName            ::= Identifier {'.' Identifier} ;

Identifier               ::= /* ASCII letter, '_' or '$' followed by letters, digits, '_' or '$'.
                               The single '_' token is reserved for discards. */ ;
NumericLiteral           ::= /* int | float | hex | bin (lexically resolved) */ ;
StringLiteral            ::= '"' /* content with escapes */ '"' ;