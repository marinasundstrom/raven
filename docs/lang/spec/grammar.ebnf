(* Raven language EBNF grammar
   This grammar captures the structural form of Raven source code.
   Contextual rules and parsing details are described in the language specification.
   NOTE: Non-normative. Context-sensitive parsing and validation live outside this EBNF. *)

CompilationUnit          ::= {ImportDirective} {AliasDirective} {Declaration | Statement} EOF ;

ImportDirective          ::= 'import' QualifiedName ('.' '*')? ; (* Namespace imports require '.*'; applying '.*' to a type imports its static members and nested types *)
AliasDirective           ::= 'alias' Identifier '=' Type ; (* Target may be a fully qualified name, type expression, literal type, or predefined type: bool | char | int | string | unit | '()' *)

(* ---------- Modifiers ---------- *)

MemberModifiers          ::= { MemberModifier } ;
MemberModifier           ::= AccessModifier
                           | 'static' | 'abstract' | 'virtual' | 'override' | 'sealed'
                           | 'readonly' | 'async' | 'extern' ;

AccessModifier           ::= 'public' | 'internal' | 'protected' | 'private' ;

AccessorModifier         ::= AccessModifier ;

TypeModifiers            ::= { TypeModifier } ;
TypeModifier             ::= AccessModifier | 'abstract' | 'sealed' | 'open' | 'static' ;

FunctionModifiers        ::= { FunctionModifier } ;
FunctionModifier         ::= AccessModifier | 'async' | 'extern' | 'static' ;

(* ---------- Declarations ---------- *)

Declaration              ::= NamespaceDeclaration
                           | FunctionDeclaration
                           | EnumDeclaration
                           | ClassDeclaration
                           | StructDeclaration ;

NamespaceDeclaration     ::= 'namespace' Identifier '{' {ImportDirective} {AliasDirective} {Declaration | Statement} '}' ;

FunctionDeclaration      ::= FunctionModifiers?
                             'func' Identifier '(' ParameterList? ')'
                             ReturnTypeClause?
                             ( Block | '=>' Expression ) ;

ReturnTypeClause         ::= '->' Type ;

ParameterList            ::= Parameter {',' Parameter} ;
Parameter                ::= ['out'] Identifier ':' Type ;

EnumDeclaration          ::= TypeModifiers?
                             'enum' Identifier '{' EnumMembers? '}' ;
EnumMembers              ::= EnumMember {',' EnumMember} ;
EnumMember               ::= Identifier ['=' Expression] ;

ClassDeclaration         ::= TypeModifiers? 'class' Identifier BaseTypeClause? ClassBody ;
BaseTypeClause           ::= ':' Type ;
StructDeclaration        ::= TypeModifiers? 'struct' Identifier ClassBody ;
ClassBody                ::= '{' {ClassMember} '}' ;

ClassMember              ::= FieldDeclaration
                           | MethodDeclaration
                           | InvocationOperatorDeclaration
                           | ConstructorDeclaration
                           | PropertyDeclaration
                           | IndexerDeclaration ;

FieldDeclaration         ::= MemberModifiers? FieldKind VariableDeclarators ';' ;
FieldKind                ::= 'let' | 'var' ;

VariableDeclarators      ::= VariableDeclarator {',' VariableDeclarator} ;
VariableDeclarator       ::= Identifier (':' Type)? ['=' Expression] ;

ConstructorDeclaration   ::= MemberModifiers?
                             'init' Identifier? '(' ParameterList? ')'
                             ( Block | '=>' Expression ) ;

MethodDeclaration        ::= MemberModifiers?
                             Identifier '(' ParameterList? ')'
                             ReturnTypeClause?
                             ( Block | '=>' Expression ) ;

InvocationOperatorDeclaration
                           ::= MemberModifiers?
                               'self' '(' ParameterList? ')'
                               ReturnTypeClause?
                               ( Block | '=>' Expression ) ;

PropertyDeclaration      ::= MemberModifiers?
                             Identifier ':' Type AccessorList ;

IndexerDeclaration       ::= MemberModifiers?
                             Identifier BracketedParameterList ':' Type AccessorList ;

AccessorList             ::= '{' Accessor {Accessor} '}' ;
Accessor                 ::= AccessorModifier? ('get' | 'set')
                             ( Block | '=>' Expression | ';' ) ;

BracketedParameterList   ::= '[' ParameterList? ']' ;

(* ---------- Statements ---------- *)

Statement                ::= LocalDeclaration
                           | ReturnStatement
                           | FunctionStatement
                           | IfStatement
                           | WhileStatement
                           | ForStatement
                           | ExpressionStatement ;

LocalDeclaration         ::= ('let' | 'var') LocalVariableDeclarators ;
LocalVariableDeclarators ::= LocalVariableDeclarator {',' LocalVariableDeclarator} ;
LocalVariableDeclarator  ::= Identifier (':' Type)? '=' Expression ;

ReturnStatement          ::= 'return' Expression? ;

FunctionStatement        ::= 'func' Identifier '(' ParameterList? ')' ReturnTypeClause? Block ;

ExpressionStatement      ::= Expression ;

IfStatement              ::= 'if' Expression Statement ['else' Statement] ;
WhileStatement           ::= 'while' Expression Statement ;
ForStatement             ::= 'for' 'each'? Identifier 'in' Expression Statement ;

(* ---------- Expressions & precedence (lowest â†’ highest) ---------- *)

Expression               ::= AssignmentExpression ;

AssignmentExpression     ::= Assignable AssignmentOperator AssignmentExpression
                           | ConditionalNullCoalesceExpression ;

AssignmentOperator       ::= '=' | '+=' | '-=' | '*=' | '/=' | '%=' ;

Assignable               ::= Identifier
                           | MemberAccessExpression
                           | MemberBindingExpression
                           | ElementAccessExpression
                           | TupleDeconstruction ;

TupleDeconstruction      ::= '(' DeconstructionElement {',' DeconstructionElement} ')' ;
DeconstructionElement    ::= Identifier | '_' | TupleDeconstruction ;

ConditionalNullCoalesceExpression
                           ::= LogicalOrExpression {'??' LogicalOrExpression} ;

LogicalOrExpression      ::= LogicalAndExpression {'||' LogicalAndExpression} ;
LogicalAndExpression     ::= EqualityExpression {'&&' EqualityExpression} ;
EqualityExpression       ::= RelationalExpression {('==' | '!=') RelationalExpression} ;
RelationalExpression     ::= TypeTestExpression
                             {('<' | '>' | '<=' | '>=') TypeTestExpression} ;

TypeTestExpression       ::= AdditiveExpression {('is' | 'as') Type} ;

AdditiveExpression       ::= MultiplicativeExpression {('+' | '-') MultiplicativeExpression} ;
MultiplicativeExpression ::= UnaryExpression {('*' | '/' | '%') UnaryExpression} ;

UnaryExpression          ::= PostfixExpression
                           | ('+' | '-' | '!') UnaryExpression
                           | CastExpression ;

CastExpression           ::= '(' Type ')' UnaryExpression ;

PostfixExpression        ::= PrimaryExpression { PostfixTrailer } ;
PostfixTrailer           ::= ArgumentList
                           | MemberAccessTrailer
                           | ElementAccessTrailer ;

ArgumentList             ::= '(' [Argument {',' Argument}] ')' ;
Argument                 ::= [Identifier ':'] Expression ;

MemberAccessTrailer      ::= '.' Identifier ;
ElementAccessTrailer     ::= '[' Expression ']' ;

MemberBindingExpression  ::= '.' Identifier ;

(* ---------- Primaries ----------
   NOTE: Block/IfExpression/WhileExpression/ForExpression can appear as expressions.
         Each also has a corresponding statement form when used in statement position. *)
PrimaryExpression        ::= Literal
                           | Identifier
                           | MemberBindingExpression
                           | ObjectCreationExpression
                           | TupleExpression
                           | ParenthesizedExpression
                           | Block
                           | IfExpression
                           | WhileExpression
                           | ForExpression
                           | InterpolatedStringExpression ;

Block                    ::= '{' {Statement} '}' ;

IfExpression             ::= 'if' Expression Expression ['else' Expression] ;
WhileExpression          ::= 'while' Expression Expression ;
ForExpression            ::= 'for' 'each'? Identifier 'in' Expression Expression ;
InterpolatedStringExpression ::= '"' {InterpolatedStringContent} '"' ;
InterpolatedStringContent ::= InterpolatedStringText | Interpolation ;
InterpolatedStringText   ::= /* text segment without ${ or closing quote */ ;
Interpolation            ::= '${' Expression '}' ;

ObjectCreationExpression ::= 'new' Type '(' [Argument {',' Argument}] ')' ;

TupleExpression          ::= '(' TupleElement {',' TupleElement} ')' ;
TupleElement             ::= [Identifier ':'] Expression ;

ParenthesizedExpression  ::= '(' Expression ')' ;

Literal                  ::= NumericLiteral
                           | StringLiteral
                           | 'true' | 'false' | 'null' ;

(* ---------- Types ---------- *)

Type                     ::= '&'? UnionType ;

UnionType                ::= NullableType {'|' NullableType} ;     (* left-assoc *)

NullableType             ::= PrimaryType ['?'] ;

PrimaryType              ::= TupleType
                           | GenericType
                           | SimpleType
                           | NullType
                           | ParenthesizedType ;

NullType                 ::= 'null' ;

SimpleType               ::= BuiltinType | QualifiedName ;
BuiltinType              ::= 'int' | 'string' | 'bool' | 'unit' | 'char' | '(' ')' ;

GenericType              ::= QualifiedName '<' TypeList '>' ;
TypeList                 ::= Type {',' Type} ;

TupleType                ::= '(' TupleTypeElement {',' TupleTypeElement} ')' ;
TupleTypeElement         ::= [Identifier ':'] Type ;
ParenthesizedType        ::= '(' Type ')' ;

QualifiedName            ::= Identifier {'.' Identifier} ;

Identifier               ::= /* letter followed by letters or digits */ ;
NumericLiteral           ::= /* int | float | hex | bin (lexically resolved) */ ;
StringLiteral            ::= '"' /* content with escapes */ '"' ;