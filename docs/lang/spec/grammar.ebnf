(* Raven language EBNF grammar
   This grammar captures the structural form of Raven source code.
   Contextual rules and parsing details are described in the language specification.
   NOTE: Non-normative. Context-sensitive parsing and validation live outside this EBNF. *)

CompilationUnit          ::= {ImportDirective} {AliasDirective} {Declaration | Statement} EOF ;

ImportDirective          ::= 'import' QualifiedName ('.' '*')? ; (* Namespace imports require '.*'; applying '.*' to a type imports its static members and nested types *)
AliasDirective           ::= 'alias' Identifier '=' Type ; (* Target may be a fully qualified name, type expression, literal type, or predefined type: bool | char | int | string | unit | '()' *)

(* ---------- Modifiers ---------- *)

MemberModifiers          ::= { MemberModifier } ;
MemberModifier           ::= AccessModifier
                           | 'static' | 'abstract' | 'virtual' | 'override' | 'final' | 'sealed' | 'new'
                           | 'readonly' | 'async' | 'extern' ;

AccessModifier           ::= 'public' | 'internal' | 'protected' | 'private' ;

AccessorModifier         ::= AccessModifier | 'async' | 'ref' | 'out' | 'in' ;

TypeModifiers            ::= { TypeModifier } ;
TypeModifier             ::= AccessModifier | 'abstract' | 'sealed' | 'open' | 'partial' | 'static' ;

FunctionModifiers        ::= { FunctionModifier } ;
FunctionModifier         ::= AccessModifier | 'async' | 'extern' | 'static' ;

(* ---------- Declarations ---------- *)

Declaration              ::= NamespaceDeclaration
                           | FunctionDeclaration
                           | ExtensionDeclaration
                           | EnumDeclaration
                           | UnionDeclaration
                           | ClassDeclaration
                           | StructDeclaration
                           | InterfaceDeclaration ;

NamespaceDeclaration     ::= 'namespace' Identifier '{' {ImportDirective} {AliasDirective} {Declaration | Statement} '}' ;

FunctionDeclaration      ::= FunctionModifiers?
                             'func' Identifier TypeParameterList?
                             '(' ParameterList? ')'
                             ReturnTypeClause?
                             WhereClauseList?
                             ( Block | '=>' Expression ) ;

ExtensionDeclaration     ::= 'extension' Identifier TypeParameterList?
                             'for' Type
                             WhereClauseList?
                             ExtensionBody ;

ExtensionBody            ::= '{' {ExtensionMember} '}' ;
ExtensionMember          ::= ExtensionMethodDeclaration
                           | ExtensionPropertyDeclaration
                           | OperatorDeclaration
                           | ConversionOperatorDeclaration ;

ExtensionMethodDeclaration
                           ::= ExtensionMethodModifiers?
                               Identifier TypeParameterList?
                               '(' ParameterList? ')'
                               ReturnTypeClause?
                               WhereClauseList?
                               ( Block | '=>' Expression ) ;

ExtensionMethodModifiers ::= AccessModifier ;

ExtensionPropertyDeclaration
                           ::= ExtensionPropertyModifiers?
                               Identifier ':' Type AccessorList ;

ExtensionPropertyModifiers ::= AccessModifier ;

ReturnTypeClause         ::= '->' Type ;

ParameterList            ::= Parameter {',' Parameter} ;
Parameter                ::= RefKindModifier? Identifier ':' Type ['=' Expression] ;
RefKindModifier          ::= 'ref' | 'out' | 'in' ;

EnumDeclaration          ::= TypeModifiers?
                             'enum' Identifier '{' EnumMembers? '}' ;
EnumMembers              ::= EnumMember {',' EnumMember} ;
EnumMember               ::= Identifier ['=' Expression] ;

ClassDeclaration         ::= TypeModifiers? 'class' Identifier TypeParameterList?
                             PrimaryConstructor? BaseList?
                             WhereClauseList?
                             ClassBody ;

PrimaryConstructor       ::= '(' ParameterList? ')' ;

StructDeclaration        ::= TypeModifiers? 'struct' Identifier TypeParameterList?
                             BaseList?
                             WhereClauseList?
                             ClassBody ;

InterfaceDeclaration     ::= TypeModifiers? 'interface' Identifier TypeParameterList?
                             BaseList?
                             WhereClauseList?
                             ClassBody ;

UnionDeclaration         ::= TypeModifiers? 'union' Identifier TypeParameterList?
                             WhereClauseList?
                             '{' UnionCaseList '}' TypeTerminator? ;

UnionCaseList            ::= UnionCaseClause {UnionCaseClause} ;
UnionCaseClause          ::= Identifier ParameterList? ;

BaseList                 ::= ':' Type {',' Type} ;

ClassBody                ::= '{' {ClassMember} '}' ;

TypeTerminator           ::= NewLineToken | ';' ;
NewLineToken             ::= /* newline trivia promoted to a token after type declarations */ ;

ClassMember              ::= FieldDeclaration
                           | MethodDeclaration
                           | ConversionOperatorDeclaration
                           | OperatorDeclaration
                           | InvocationOperatorDeclaration
                           | ConstructorDeclaration
                           | EventDeclaration
                           | PropertyDeclaration
                           | IndexerDeclaration ;

FieldDeclaration         ::= MemberModifiers? FieldKind VariableDeclarators ';' ;
FieldKind                ::= 'let' | 'val' | 'var' | 'const' ;

VariableDeclarators      ::= VariableDeclarator {',' VariableDeclarator} ;
VariableDeclarator       ::= Identifier (':' Type)? ['=' Expression] ;

ConstructorDeclaration   ::= MemberModifiers?
                             'init' Identifier? '(' ParameterList? ')'
                             ( Block | '=>' Expression ) ;

MethodDeclaration        ::= MemberModifiers?
                             ExplicitInterfaceSpecifier?
                             Identifier TypeParameterList?
                             '(' ParameterList? ')'
                             ReturnTypeClause?
                             WhereClauseList?
                             ( Block | '=>' Expression ) ;

ConversionOperatorDeclaration
                         ::= MemberModifiers?
                             ( 'explicit' | 'implicit' ) 'operator' TypeParameterList?
                             '(' ParameterList? ')'
                             ReturnTypeClause?
                             WhereClauseList?
                             ( Block | '=>' Expression ) ;

OperatorDeclaration      ::= MemberModifiers?
                             'operator' OverloadableOperator TypeParameterList?
                             '(' ParameterList? ')'
                             ReturnTypeClause?
                             WhereClauseList?
                             ( Block | '=>' Expression ) ;

OverloadableOperator     ::= '+' | '-' | '*' | '/' | '%' | '^' | '&' | '&&' | 'and'
                           | '|' | '||' | 'or' | '==' | '!=' | '<' | '<=' | '>'
                           | '>=' | '!' | '++' | '--' ;

ExplicitInterfaceSpecifier ::= Type '.' ;

InvocationOperatorDeclaration
                           ::= MemberModifiers?
                               'self' TypeParameterList?
                               '(' ParameterList? ')'
                               ReturnTypeClause?
                               WhereClauseList?
                               ( Block | '=>' Expression ) ;

PropertyDeclaration      ::= MemberModifiers?
                             ExplicitInterfaceSpecifier? Identifier ':' Type AccessorList ;

IndexerDeclaration       ::= MemberModifiers?
                             ExplicitInterfaceSpecifier? Identifier BracketedParameterList ':' Type AccessorList ;

EventDeclaration         ::= MemberModifiers?
                             ExplicitInterfaceSpecifier? 'event' Identifier ':' Type ( EventAccessorList | ';' ) ;

AccessorList             ::= '{' Accessor {Accessor} '}' ;
Accessor                 ::= AccessorModifier? ('get' | 'set')
                             ( Block | '=>' Expression | ';' ) ;

EventAccessorList        ::= '{' EventAccessor {EventAccessor} '}' ;
EventAccessor            ::= AccessorModifier? ('add' | 'remove')
                             ( Block | '=>' Expression | ';' ) ;

BracketedParameterList   ::= '[' ParameterList? ']' ;

(* ---------- Generics & constraints ---------- *)

TypeParameterList        ::= '<' TypeParameter {',' TypeParameter} '>' ;

TypeParameter            ::= Variance? Identifier InlineConstraints? ;

InlineConstraints        ::= ':' TypeParameterConstraintList ;

Variance                 ::= 'out' | 'in' ;

WhereClauseList          ::= WhereClause { WhereClause } ;

WhereClause              ::= 'where' Identifier ':' TypeParameterConstraintList ;

TypeParameterConstraintList
                         ::= TypeParameterConstraint {',' TypeParameterConstraint} ;

TypeParameterConstraint  ::= 'class'            (* reference type constraint *)
                           | 'struct'           (* value type constraint *)
                           | 'notnull'          (* non-null constraint *)
                           | 'unmanaged'        (* unmanaged constraint *)
                           | 'new' '(' ')'      (* public parameterless ctor *)
                           | Type ;             (* base class / interface constraint *)

(* ---------- Statements ---------- *)

(* Newline tokens act as implicit statement terminators unless the parser is
   in a continuation context that still requires more of the current
   expression—such as immediately after '=' or a binary operator. In those
   cases the newline is preserved as trivia on the next token instead of
   ending the statement. Other terminators, including ';', '}', and keywords
   like 'else' that conclude the enclosing construct, serve the same role when
   they appear. *)

Statement                ::= LocalDeclaration
                           | ReturnStatement
                           | ThrowStatement
                           | BreakStatement
                           | ContinueStatement
                           | FunctionStatement
                           | IfStatement
                           | WhileStatement
                           | ForStatement
                           | TryStatement
                           | AssignmentStatement
                           | ExpressionStatement ;

LocalDeclaration         ::= ('let' | 'val' | 'var' | 'const') LocalVariableDeclarators ;
LocalVariableDeclarators ::= LocalVariableDeclarator {',' LocalVariableDeclarator} ;
LocalVariableDeclarator  ::= Identifier (':' Type)? '=' Expression ;

ReturnStatement          ::= 'return' Expression? ;
ThrowStatement           ::= 'throw' Expression ;
BreakStatement           ::= 'break' ;
ContinueStatement        ::= 'continue' ;

FunctionStatement        ::= 'async'? 'func' Identifier TypeParameterList?
                             '(' ParameterList? ')'
                             ReturnTypeClause?
                             WhereClauseList?
                             Block ;

ExpressionStatement      ::= Expression ;

IfStatement              ::= 'if' Expression Statement ['else' Statement] ;
WhileStatement           ::= 'while' Expression Statement ;
ForStatement             ::= 'for' 'each'? ForIterationVariable? 'in' Expression Statement ;
ForIterationVariable     ::= Identifier | '_' ;

TryStatement             ::= 'try' Block (CatchClauseList [FinallyClause] | FinallyClause) ;
CatchClauseList          ::= CatchClause {CatchClause} ;
CatchClause              ::= 'catch' CatchDeclaration? Block ;
CatchDeclaration         ::= '(' Type [Identifier] ')' ;
FinallyClause            ::= 'finally' Block ;

(* Keep statement assignments consistent with expression assignments:
   - LHS must be assignable OR a deconstruction designation.
   - Patterns are NOT assignment targets. *)
AssignmentStatement      ::= Assignable AssignmentOperator Expression
                           | DeconstructionAssignmentStatement ;

DeconstructionAssignmentStatement
                         ::= VariableDesignation AssignmentOperator Expression ;

(* ---------- Expressions & precedence (lowest → highest) ---------- *)

Expression               ::= AssignmentExpression {MatchExpressionSuffix} ;

MatchExpressionSuffix    ::= 'match' '{' MatchArmList '}' ;
MatchArmList             ::= MatchArm {MatchArm} ;
MatchArm                 ::= Pattern MatchGuardClause? '=>' Expression MatchArmTerminator? ;
MatchGuardClause         ::= 'when' Expression ;
MatchArmTerminator       ::= NewLineToken | ';' ;

AssignmentExpression     ::= Assignable AssignmentOperator AssignmentExpression
                           | DeconstructionAssignment
                           | ConditionalNullCoalesceExpression ;

DeconstructionAssignment ::= VariableDesignation AssignmentOperator AssignmentExpression ;

AssignmentOperator       ::= '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' ;

Assignable               ::= Identifier
                           | MemberAccessExpression
                           | MemberBindingExpression
                           | ElementAccessExpression ;

(* ---------- Patterns ---------- *)

Pattern                  ::= OrPattern ;

OrPattern                ::= AndPattern {'or' AndPattern} ;
AndPattern               ::= UnaryPattern {'and' UnaryPattern} ;
UnaryPattern             ::= 'not' UnaryPattern | PrimaryPattern ;

PrimaryPattern           ::= ParenthesizedPattern
                           | RelationalPattern
                           | ConstantPattern
                           | VariablePattern
                           | DeclarationPattern
                           | TuplePattern
                           | DiscardPattern
                           | CasePattern
                           | PropertyPattern ;

ConstantPattern          ::= Literal | ConstantPatternOperand ;

ConstantPatternOperand    ::= Identifier ;
(* A bare identifier in pattern position is context-sensitive:
   - If it binds to an in-scope value, it is a value/constant pattern (matches by equality).
   - Otherwise it is interpreted as a type name and forms a DeclarationPattern.
   This disambiguation is performed by the binder. *)

BindingKeyword           ::= 'let' | 'val' | 'var' ;

VariablePattern          ::= BindingKeyword VariableDesignation ;

(* NOTE: A single Identifier can be parsed as either ConstantPatternOperand or as the `Type` in a
   DeclarationPattern. The binder resolves the ambiguity by preferring a value/constant pattern
   when the identifier resolves to a value symbol in scope; otherwise it is treated as a type. *)
DeclarationPattern       ::= Type [VariableDesignation] ;

TuplePattern             ::= '(' PatternElement ',' PatternElement {',' PatternElement} ')' ;
PatternElement           ::= [TuplePatternElementDesignation] Pattern ;

(* Tuple element designations introduce a new binding for the element.
   To avoid ambiguity with value/constant patterns, the binding keyword is required.
   For example: (val a: bool, _) is permitted, but (a: bool, _) is an error. *)
TuplePatternElementDesignation
                         ::= BindingKeyword Identifier ':' ;

DiscardPattern           ::= '_' | Type '_' ;

CasePattern              ::= CasePath [ '(' PatternList? ')' ] ;
CasePath                 ::= '.' Identifier
                           | Type '.' Identifier ;

PatternList              ::= Pattern {',' Pattern} ;

PropertyPattern          ::= Type? '{' PropertySubpatternList? '}' PropertyPatternDesignation? ;
PropertySubpatternList   ::= PropertySubpattern {',' PropertySubpattern} ;
PropertySubpattern       ::= Identifier ':' Pattern ;

PropertyPatternDesignation
                         ::= VariableDesignation
                           | '_' ;

ParenthesizedPattern     ::= '(' Pattern ')' ;

RelationalPattern        ::= RelationalOperator RelationalPatternOperand ;
RelationalOperator       ::= '<' | '<=' | '>' | '>=' | '==' | '!=' ;
RelationalPatternOperand ::= Expression ; (* binder should enforce “constant-ish” rules *)

VariableDesignation      ::= VariableDesignationCore [':' Type] ; (* In patterns, a type annotation requires an explicit BindingKeyword (let/val/var) on each single variable. *)
VariableDesignationCore  ::= SingleVariableDesignation | ParenthesizedVariableDesignation ;
SingleVariableDesignation ::= [BindingKeyword] Identifier ;

ParenthesizedVariableDesignation
                         ::= '(' VariableDesignation {',' VariableDesignation} ')' ;

ConditionalNullCoalesceExpression
                         ::= LogicalOrExpression {'??' LogicalOrExpression} ;

LogicalOrExpression      ::= LogicalAndExpression {'||' LogicalAndExpression} ;
LogicalAndExpression     ::= BitwiseOrExpression {'&&' BitwiseOrExpression} ;
BitwiseOrExpression      ::= BitwiseAndExpression {'|' BitwiseAndExpression} ;
BitwiseAndExpression     ::= EqualityExpression {'&' EqualityExpression} ;
EqualityExpression       ::= RelationalExpression {('==' | '!=') RelationalExpression} ;
RelationalExpression     ::= TypeTestExpression
                             {('<' | '>' | '<=' | '>=') TypeTestExpression} ;

TypeTestExpression       ::= RangeExpression { 'as' Type } [ 'is' Pattern ] ;

RangeExpression          ::= RangeStart '..' RangeEnd
                           | AdditiveExpression ;

RangeStart               ::= RangeIndex? ;
RangeEnd                 ::= RangeIndex? ;
RangeIndex               ::= '^'? AdditiveExpression ;

AdditiveExpression       ::= MultiplicativeExpression {('+' | '-') MultiplicativeExpression} ;
MultiplicativeExpression ::= UnaryExpression {('*' | '/' | '%') UnaryExpression} ;

UnaryExpression          ::= LambdaExpression
                           | PostfixExpression
                           | ('+' | '-' | '!') UnaryExpression
                           | 'await' UnaryExpression
                           | CastExpression ;

LambdaExpression         ::= 'async'? LambdaParameterClause ReturnTypeClause? '=>' Expression ;
LambdaParameterClause    ::= '(' ParameterList? ')' | Parameter ;

CastExpression           ::= '(' Type ')' UnaryExpression ;

PostfixExpression        ::= PrimaryExpression { PostfixTrailer } ;
PostfixTrailer           ::= ArgumentList
                           | MemberAccessTrailer
                           | ElementAccessTrailer
                           | ConditionalAccessTrailer ;

ArgumentList             ::= '(' [Argument {',' Argument}] ')' ;
Argument                 ::= [Identifier ':'] Expression ;

MemberAccessTrailer      ::= '.' Identifier ;
ElementAccessTrailer     ::= '[' Expression ']' ;
ConditionalAccessTrailer ::= '?' (MemberAccessTrailer | ElementAccessTrailer | ArgumentList) ;

MemberBindingExpression  ::= '.' Identifier ;

(* ---------- Primaries ----------
   NOTE: Block and IfExpression can appear as expressions.
         While and for constructs exist only as statements. *)

PrimaryExpression        ::= Literal
                           | DefaultExpression
                           | Identifier
                           | MemberBindingExpression
                           | ObjectCreationExpression
                           | TupleExpression
                           | ParenthesizedExpression
                           | TryExpression
                           | Block
                           | IfExpression
                           | InterpolatedStringExpression ;

DefaultExpression        ::= 'default' | 'default' '(' Type ')' ;

TryExpression            ::= 'try' Expression ;

Block                    ::= '{' {Statement} '}' ;

IfExpression             ::= 'if' Expression Expression 'else' Expression ;

InterpolatedStringExpression
                         ::= '"' {InterpolatedStringContent} '"' ;
InterpolatedStringContent ::= InterpolatedStringText | Interpolation ;
InterpolatedStringText   ::= /* text segment without ${ or closing quote */ ;
Interpolation            ::= '${' Expression '}' ;

ObjectCreationExpression ::= 'new' Type '(' [Argument {',' Argument}] ')' ;

TupleExpression          ::= '(' TupleElement {',' TupleElement} ')' ;
TupleElement             ::= [Identifier ':'] Expression ;

ParenthesizedExpression  ::= '(' Expression ')' ;

Literal                  ::= NumericLiteral
                           | StringLiteral
                           | 'true' | 'false' | 'null' ;

(* ---------- Types ---------- *)

Type                     ::= ByRefType | PointerType | UnionType ;

ByRefType                ::= '&' Type ;
PointerType              ::= '*' Type ;

UnionType                ::= FunctionType {'|' FunctionType} ; (* left-assoc *)

FunctionType             ::= FunctionParameterClause '->' Type
                           | NullableType ;

FunctionParameterClause  ::= FunctionTypeParameterList | NullableType ;

FunctionTypeParameterList
                         ::= '(' [Type {',' Type}] ')' ;

NullableType             ::= PrimaryType ['?'] ;

PrimaryType              ::= TupleType
                           | GenericType
                           | SimpleType
                           | NullType
                           | ParenthesizedType ;

NullType                 ::= 'null' ;

SimpleType               ::= BuiltinType | QualifiedName ;
BuiltinType              ::= 'int' | 'long' | 'float' | 'double' | 'decimal' | 'string' | 'bool' | 'unit' | 'char' | '(' ')' ;

GenericType              ::= QualifiedName '<' TypeList '>' ;
TypeList                 ::= Type {',' Type} ;

TupleType                ::= '(' TupleTypeElement {',' TupleTypeElement} ')' ;
TupleTypeElement         ::= [Identifier ':'] Type ;

ParenthesizedType        ::= '(' Type ')' ;

QualifiedName            ::= Identifier {'.' Identifier} ;

Identifier               ::= /* ASCII letter, '_' or '$' followed by letters, digits, '_' or '$'.
                               The single '_' token is reserved for discards. */ ;

StringLiteral            ::= '"' {InterpolatedStringText | Interpolation} '"' ;
InterpolatedStringText   ::= /* content with escapes */ ;
Interpolation            ::= '$' Identifier | '$' '{' Expression '}' ;

(* ---------- Numeric literals (lexical forms) ---------- *)

(* Numeric literals are lexically resolved by the lexer. This grammar documents the allowed surface forms.

   Examples:
     1        (* integer *)
     1.0      (* decimal-point real *)
     .0       (* leading-dot real *)
     1e3      (* exponent real *)
     0xFF     (* hex integer *)
     0b1010   (* binary integer *)

   Suffixes (optional, case-insensitive):
     B  -> byte
     L  -> long
     F  -> float
     D  -> double
     M  -> decimal

   If no suffix is present, the default type is determined by the lexer:
     - integer literals default to int (or a wider integral type if specified/required by the binder)
     - real literals default to double
*)

NumericLiteral           ::= IntegerLiteral NumericSuffix?
                           | RealLiteral NumericSuffix? ;

NumericSuffix            ::=  'b' | 'B'
                           | 'l' | 'L'
                           | 'f' | 'F'
                           | 'd' | 'D'
                           | 'm' | 'M' ;

IntegerLiteral           ::= DecimalIntegerLiteral
                           | HexIntegerLiteral
                           | BinaryIntegerLiteral ;

DecimalIntegerLiteral    ::= DecimalDigits ;
HexIntegerLiteral        ::= '0' ('x' | 'X') HexDigits ;
BinaryIntegerLiteral     ::= '0' ('b' | 'B') BinaryDigits ;

(* Real literals support:
   - a decimal point: 1.0, 1., .0
   - an exponent: 1e3, 1.0e-3, .5E+2
   A real literal must contain either a '.' or an exponent part (or both). *)
RealLiteral              ::= RealWithDot ExponentPart?
                           | DecimalDigits ExponentPart ;

RealWithDot              ::= DecimalDigits '.' DecimalDigits?
                           | '.' DecimalDigits ;

ExponentPart             ::= ('e' | 'E') Sign? DecimalDigits ;
Sign                     ::= '+' | '-' ;

DecimalDigits            ::= DecimalDigit { DecimalDigit | '_' } ;
HexDigits                ::= HexDigit { HexDigit | '_' } ;
BinaryDigits             ::= BinaryDigit { BinaryDigit | '_' } ;

DecimalDigit             ::= '0'..'9' ;
HexDigit                 ::= DecimalDigit | 'a'..'f' | 'A'..'F' ;
BinaryDigit              ::= '0' | '1' ;