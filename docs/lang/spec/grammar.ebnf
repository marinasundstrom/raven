(* Raven language EBNF grammar
   This grammar captures the structural form of Raven source code.
   Contextual rules and parsing details are described in the language specification.
   NOTE: Non-normative. Context-sensitive parsing and validation live outside this EBNF. *)

CompilationUnit          ::= {ImportDirective | Declaration | Statement} EOF ;

ImportDirective          ::= 'import' QualifiedName ('.' '*')? ; (* Namespace imports require '.*'; applying '.*' to a type imports its static members and nested types *)

(* ---------- Modifiers ---------- *)

MemberModifiers          ::= { MemberModifier } ;
MemberModifier           ::= AccessModifier
                           | 'static' | 'abstract' | 'virtual' | 'override' | 'sealed'
                           | 'readonly' | 'async' | 'extern' ;

AccessModifier           ::= 'public' | 'internal' | 'protected' | 'private' ;

AccessorModifier         ::= AccessModifier ;

TypeModifiers            ::= { TypeModifier } ;
TypeModifier             ::= AccessModifier | 'abstract' | 'sealed' | 'static' ;

FunctionModifiers        ::= { FunctionModifier } ;
FunctionModifier         ::= AccessModifier | 'async' | 'extern' | 'static' ;

(* ---------- Declarations ---------- *)

Declaration              ::= NamespaceDeclaration
                           | FunctionDeclaration
                           | EnumDeclaration
                           | ClassDeclaration
                           | StructDeclaration ;

NamespaceDeclaration     ::= 'namespace' Identifier Block ;

FunctionDeclaration      ::= FunctionModifiers?
                             'func' Identifier '(' ParameterList? ')'
                             ReturnTypeClause?
                             ( Block | '=>' Expression ) ;

ReturnTypeClause         ::= '->' Type ;

ParameterList            ::= Parameter {',' Parameter} ;
Parameter                ::= Identifier ':' Type ;

EnumDeclaration          ::= TypeModifiers?
                             'enum' Identifier '{' EnumMembers? '}' ;
EnumMembers              ::= EnumMember {',' EnumMember} ;
EnumMember               ::= Identifier ['=' Expression] ;

ClassDeclaration         ::= TypeModifiers? 'class' Identifier ClassBody ;
StructDeclaration        ::= TypeModifiers? 'struct' Identifier ClassBody ;
ClassBody                ::= '{' {ClassMember} '}' ;

ClassMember              ::= FieldDeclaration
                           | MethodDeclaration
                           | ConstructorDeclaration
                           | PropertyDeclaration
                           | IndexerDeclaration ;

FieldDeclaration         ::= MemberModifiers? FieldKind VariableDeclarators ';' ;
FieldKind                ::= 'let' | 'var' ;

VariableDeclarators      ::= VariableDeclarator {',' VariableDeclarator} ;
VariableDeclarator       ::= Identifier (':' Type)? ['=' Expression] ;

ConstructorDeclaration   ::= MemberModifiers?
                             'init' Identifier? '(' ParameterList? ')'
                             ( Block | '=>' Expression ) ;

MethodDeclaration        ::= MemberModifiers?
                             Identifier '(' ParameterList? ')'
                             ReturnTypeClause?
                             ( Block | '=>' Expression ) ;

PropertyDeclaration      ::= MemberModifiers?
                             Identifier ':' Type AccessorList ;

IndexerDeclaration       ::= MemberModifiers?
                             Identifier BracketedParameterList ':' Type AccessorList ;

AccessorList             ::= '{' Accessor {Accessor} '}' ;
Accessor                 ::= AccessorModifier? ('get' | 'set')
                             ( Block | '=>' Expression | ';' ) ;

BracketedParameterList   ::= '[' ParameterList? ']' ;

(* ---------- Statements ----------
   NOTE: Raven has no separate If/While *statements*.
         Standalone control flow uses ExpressionStatement with IfExpression/WhileExpression. *)

Statement                ::= LocalDeclaration
                           | ReturnStatement
                           | ExpressionStatement ;

LocalDeclaration         ::= ('let' | 'var') LocalVariableDeclarators ;
LocalVariableDeclarators ::= LocalVariableDeclarator {',' LocalVariableDeclarator} ;
LocalVariableDeclarator  ::= Identifier (':' Type)? '=' Expression ;

ReturnStatement          ::= 'return' Expression? ;

ExpressionStatement      ::= Expression ;

(* ---------- Expressions & precedence (lowest → highest) ---------- *)

Expression               ::= AssignmentExpression ;

AssignmentExpression     ::= Assignable AssignmentOperator AssignmentExpression
                           | ConditionalNullCoalesceExpression ;

AssignmentOperator       ::= '=' | '+=' | '-=' | '*=' | '/=' | '%=' ;

Assignable               ::= Identifier
                           | MemberAccessExpression
                           | ElementAccessExpression
                           | TupleDeconstruction ;

TupleDeconstruction      ::= '(' DeconstructionElement {',' DeconstructionElement} ')' ;
DeconstructionElement    ::= Identifier | '_' | TupleDeconstruction ;

ConditionalNullCoalesceExpression
                           ::= LogicalOrExpression {'??' LogicalOrExpression} ;

LogicalOrExpression      ::= LogicalAndExpression {'||' LogicalAndExpression} ;
LogicalAndExpression     ::= EqualityExpression {'&&' EqualityExpression} ;
EqualityExpression       ::= RelationalExpression {('==' | '!=') RelationalExpression} ;
RelationalExpression     ::= TypeTestExpression
                             {('<' | '>' | '<=' | '>=') TypeTestExpression} ;

TypeTestExpression       ::= AdditiveExpression {('is' | 'as') Type} ;

AdditiveExpression       ::= MultiplicativeExpression {('+' | '-') MultiplicativeExpression} ;
MultiplicativeExpression ::= UnaryExpression {('*' | '/' | '%') UnaryExpression} ;

UnaryExpression          ::= PostfixExpression
                           | ('+' | '-' | '!') UnaryExpression ;

PostfixExpression        ::= PrimaryExpression { PostfixTrailer } ;
PostfixTrailer           ::= ArgumentList
                           | MemberAccessTrailer
                           | ElementAccessTrailer ;

ArgumentList             ::= '(' [Argument {',' Argument}] ')' ;
Argument                 ::= [Identifier ':'] Expression ;

MemberAccessTrailer      ::= '.' Identifier ;
ElementAccessTrailer     ::= '[' Expression ']' ;

(* ---------- Primaries ----------
   NOTE: Block/IfExpression/WhileExpression can appear as expressions,
         so `if (…) … [else …]` and `while (…) …` can be used as statements via ExpressionStatement. *)
PrimaryExpression        ::= Literal
                           | Identifier
                           | ObjectCreationExpression
                           | TupleExpression
                           | ParenthesizedExpression
                           | Block
                           | IfExpression
                           | WhileExpression ;

Block                    ::= '{' {Statement} '}' ;

IfExpression             ::= 'if' Expression Expression ['else' Expression] ;
WhileExpression          ::= 'while' Expression Expression ;

ObjectCreationExpression ::= 'new' Type '(' [Argument {',' Argument}] ')' ;

TupleExpression          ::= '(' TupleElement {',' TupleElement} ')' ;
TupleElement             ::= [Identifier ':'] Expression ;

ParenthesizedExpression  ::= '(' Expression ')' ;

Literal                  ::= NumericLiteral
                           | StringLiteral
                           | 'true' | 'false' | 'null' ;

(* ---------- Types ---------- *)

Type                     ::= UnionType ;

UnionType                ::= Intersection {'|' Intersection} ;     (* left-assoc *)

Intersection             ::= PrimaryType ;                         (* reserved for future '&' *)

PrimaryType              ::= TupleType
                           | GenericType
                           | SimpleType
                           | ParenthesizedType ;

SimpleType               ::= BuiltinType | QualifiedName ;
BuiltinType              ::= 'int' | 'string' | 'bool' | 'void' | 'char' ;

GenericType              ::= QualifiedName '<' TypeList '>' ;
TypeList                 ::= Type {',' Type} ;

TupleType                ::= '(' Type {',' Type} ')' ;
ParenthesizedType        ::= '(' Type ')' ;

QualifiedName            ::= Identifier {'.' Identifier} ;

Identifier               ::= /* letter followed by letters or digits */ ;
NumericLiteral           ::= /* int | float | hex | bin (lexically resolved) */ ;
StringLiteral            ::= '"' /* content with escapes */ '"' ;