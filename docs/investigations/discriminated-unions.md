# Discriminated unions investigation

The parser implements the syntax and case clauses described in the discriminated union proposal, and the semantic model already builds `SourceDiscriminatedUnionSymbol`/`SourceDiscriminatedUnionCaseTypeSymbol` instances for declarations such as `samples/discriminated-unions.rav`.【F:docs/lang/proposals/discriminated-unions.md†L1-L72】【F:src/Raven.CodeAnalysis/SemanticModel.cs†L916-L1120】【F:samples/discriminated-unions.rav†L1-L38】 What we lack today are the binder, pattern, and ordering features required to type-check those declarations and emit the associated constructors, payload storage, and helpers. This document tracks the concrete gaps uncovered while trying to compile the sample and the follow-up work necessary to make the feature runnable end-to-end.

## Reproduction status

`dotnet run --project src/Raven.Compiler -- samples/discriminated-unions.rav` still fails because the match arms use `.Identifier(text)`/`.Ok(value)` patterns that the current binder does not understand. The `.Ok(...)`/`.Error(...)` expressions now bind to the case constructors, so the remaining diagnostics are:

* `RAV1001`/`RAV0103` – The `match` arms use `.Identifier(text)`/`.Ok(value)` patterns, but `BoundIsPatternExpression.BindPattern` only handles discard, variable, declaration, tuple, unary, and binary patterns. Because the leading-dot syntax is treated as an unknown pattern kind, the binder throws `NotImplementedException`, which surfaces as the parser/binder errors called out in the sample README.【F:src/Raven.CodeAnalysis/BoundTree/BoundIsPatternExpression.cs†L241-L339】【F:samples/discriminated-unions.rav†L20-L38】
Even after fixing the errors above, the current compiler would still stop short of runnable unions because it never synthesizes the `TryGet*` helpers promised by the proposal, and no lowerer path emits the `match` desugaring that consumes those helpers. The sections below break down the remaining implementation work. The existing `FileScopedCodeOutOfOrder` restriction still applies, so the sample keeps its global statements at the top of the file and groups union declarations with the other type members that follow.【F:samples/discriminated-unions.rav†L1-L38】

## Binder and pattern work

1. **Constructor binding for `.Case(...)` expressions.** ✅ The member-binding branch of `BindInvocationExpression` now mirrors the member-access logic when it sees a `BoundTypeExpression`, so the shorthand routes through `BindConstructorInvocation` instead of falling back to `Invoke`. `MemberBindingInvocation_TargetTypedCase_BindsConstructor` exercises this path to guard the regression. 【F:src/Raven.CodeAnalysis/Binder/BlockBinder.cs†L3496-L3540】【F:test/Raven.CodeAnalysis.Tests/Semantics/DiscriminatedUnionSemanticTests.cs†L38-L74】
2. **Pattern recognition for union cases.** Add a new pattern kind that matches the leading-dot syntax and binds it as a declaration pattern whose type comes from the nested case struct returned by `TryBindDiscriminatedUnionCase`. Exhaustiveness checking can then reason about `IDiscriminatedUnionSymbol.Cases`, and the lowerer will have the type information required to produce `TryGet*` calls once those helpers exist.【F:src/Raven.CodeAnalysis/Binder/BlockBinder.cs†L2002-L2215】【F:src/Raven.CodeAnalysis/BoundTree/BoundIsPatternExpression.cs†L241-L339】
3. **Top-level statement ordering.** ✅ Completed. Rather than relaxing `CreateTopLevelBinder`, the samples and unit tests now keep union declarations (and all other types) after the file's top-level statements so the existing `FileScopedCodeOutOfOrder` rule is satisfied.【F:samples/discriminated-unions.rav†L1-L38】【F:test/Raven.CodeAnalysis.Tests/Samples/SampleProgramsTests.cs†L39-L69】
4. **Implicit case-to-union conversions.** ✅ Each case clause now synthesizes a `public static implicit operator Union(Case value)` method on the containing union so target-typed construction, argument passing, and cross-assembly consumers can rely on the same implicit conversion surface area that inheritance normally provides. The conversion methods lower to tag/payload assignments, so the emitted IL centralizes the logic instead of inlining it at every call site.【F:src/Raven.CodeAnalysis/SemanticModel.cs†L960-L1011】【F:src/Raven.CodeAnalysis/CodeGen/MethodBodyGenerator.cs†L130-L196】

## Code generation gaps

* **Helper emission.** `RegisterUnionCases` synthesizes constructors, payload fields, and accessors, but nothing emits the `TryGetIdentifier`-style helpers that the proposal describes. We need to generate a method per case (plus an exhaustive switch in the match lowerer) that reads `<Tag>`/`<Payload>` and projects the nested struct. Those helpers will unblock both `match` expressions and direct consumption scenarios where users call `tryGet` themselves.【F:src/Raven.CodeAnalysis/SemanticModel.cs†L916-L1120】【F:docs/lang/proposals/discriminated-unions.md†L34-L72】
* **Lowering and IL generation.** `LowerDiscriminatedUnionConversion` now only kicks in for legacy unions that were emitted without implicit operators, but pattern matching still needs a lowering strategy that calls the generated helpers and guards the payload projection. Once helper synthesis exists, extend the lowering phase to emit the helper calls and wire them into `match` arms so the sample's exhaustive switch lowers into nested `if`/`else` blocks that inspect `<Tag>` and `<Payload>`.【F:src/Raven.CodeAnalysis/BoundTree/Lowering/Lowerer.Conversions.cs†L14-L70】
* **Case property getters.** `MethodBodyGenerator` already contains a special-case path for generating case property getters when `ContainingType.TryGetDiscriminatedUnionCase()` succeeds, but we do not yet exercise that codepath because none of the existing samples emit case types. Once binding succeeds, ensure we have regression coverage that these auto-generated accessors load the synthesized backing fields correctly.【F:src/Raven.CodeAnalysis/CodeGen/MethodBodyGenerator.cs†L120-L175】

## Next steps

1. Extend the pattern binder so the parser can successfully bind the sample without throwing `NotImplementedException` or reporting `RAV1001`/`RAV0103`.
2. ✅ Keep union declarations after the file's top-level statements so the compiler never reports `FileScopedCodeOutOfOrder` for discriminated union samples.
3. Synthesize `TryGet*` helpers and teach the lowerer/matcher to consume them, following the shape laid out in the proposal.
4. Add semantic and end-to-end tests that cover both non-generic (`Token`) and generic (`Result<T>`) unions, including construction, pattern matching, and payload accessors.
