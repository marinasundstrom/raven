# Parser hardening and hang prevention

## Current recovery surface
* `BaseParseContext.SkipUntil` preserves unrecognized tokens as `SkippedTokensTrivia` before resynchronizing at an expected token or end-of-file. This keeps the token stream moving while retaining trivia for later diagnostics.【F:src/Raven.CodeAnalysis/Syntax/InternalSyntax/Parser/Parsers/BaseParseContext.cs†L453-L495】
* `SyntaxParser` threads skipped tokens into leading trivia on statement terminators or adds them to pending trivia when abandoning a construct, letting the parse continue even after local failures.【F:src/Raven.CodeAnalysis/Syntax/InternalSyntax/Parser/Parsers/SyntaxParser.cs†L305-L343】

## Logic-focused action points
1. **Guarantee forward progress per loop**: add guards that assert token position advances inside parsing loops; if no progress is detected, forcibly consume one token with `SkippedTokensTrivia` and emit a diagnostic to avoid infinite iterations.
2. **Synchronized recovery sets**: define recovery token sets per non-terminal (e.g., statement/decl/expr) and reuse `SkipUntil` with those sets instead of ad-hoc checks. This centralizes resynchronization and reduces chances of getting stuck waiting for an absent terminator.
3. **Cap skipped-token batches**: limit the number of tokens accumulated in a single `SkippedTokensTrivia` block and flush periodically to prevent large trivia lists that slow subsequent parsing and binding.
4. **Missing-node insertion**: prefer constructing placeholder nodes when required tokens are absent (paired delimiters, statement headers), then resume parsing after a bounded skip, ensuring the tree stays well-formed for later stages.
5. **Newline/brace heuristics**: when optional delimiters are missing, fall back to newline- or indentation-based recovery (e.g., treat blank line as statement end) to keep parsing progressing through blocks.
6. **SkippedTokens-aware diagnostics**: surface diagnostics that highlight skipped ranges and suggest likely fixes; ensure structured trivia survives into later phases so IDE layers can render recoverable errors without halting the parser.
7. **EOF-stall handling**: ensure progress guards bail out cleanly at end-of-file so incomplete constructs finish with missing child tokens/nodes instead of throwing or hanging when the stream is exhausted.

## Infrastructure-focused action points
1. **Cancellation and timeout plumbing**: thread a `CancellationToken` through parser entry points and compilation drivers, and add optional wall-clock timeouts to break out of hung parses during CI or IDE sessions.
2. **Parser progress watchdog**: add a debug-only watchdog that records the last consumed token index/time and triggers a failure (or aggressive skip) if no progress occurs after N iterations, capturing contextual traces for debugging.
3. **Stress and fuzz harnesses**: integrate grammar fuzzing and large-random-file stress tests into CI, asserting that parsing completes within bounded time and that the tree remains non-null even with many `SkippedTokens` blocks.
4. **Trace logging hooks**: provide opt-in verbose tracing around critical parse loops and `SkipUntil` calls, with counters for skipped tokens and recovery hits to spot hotspots that could hang.
5. **Benchmark + heap guardrails**: add benchmarks that parse pathological inputs (deep nesting, unmatched delimiters) while measuring allocations from `SkippedTokensTrivia`; flag regressions that correlate with hangs or excessive memory use.
6. **Crash dumps for hangs**: when watchdogs/CI detect a hang, automatically capture stack traces (e.g., `dotnet-trace`/`dotnet-dump`) and store them as artifacts to speed up root-cause analysis.

## Progress
* Parser entry points now accept cancellation and timeout inputs. `SyntaxTree.ParseText` links caller tokens with an optional wall-clock timeout so hung parses terminate promptly, and the CLI exposes `--parse-timeout` to enforce the same budget when invoking `ravenc` from CI or editor integrations.
* Added a debug-only parser progress watchdog that tracks token positions and raises an exception when loops spin without advancing for too long, improving visibility into potential hangs during development and CI runs. The watchdog is now wired into token peeks, reads, and rewinds so stalled iterations are observed instead of silently looping.
* Added loop-level progress guards across parsing hot spots to force forward motion when a loop stops advancing. Stalled iterations now skip a token with `SkippedTokensTrivia` and emit an internal parser diagnostic so recovery continues instead of hanging indefinitely without surfacing the skipped-token detail to end users.
* Introduced shared recovery token sets for statements, expressions, and member lists, and wired them into statement terminator recovery plus type/extension/enum member loops so resynchronization always targets known boundaries instead of relying on ad-hoc skip conditions.
* Capped skipped-token trivia batches during recovery and loop stalls to flush large invalid regions in smaller chunks, preventing giant `SkippedTokensTrivia` payloads from slowing down parsing and later phases.
* When recovery hits a statement boundary without a terminator, the parser now inserts a missing semicolon token and reports a diagnostic so subsequent phases see a well-formed tree instead of a placeholder `None` token.
* Block parsing now inserts a missing `}` and reports a diagnostic when the closing brace is absent, avoiding unbounded reads to end-of-file while keeping statement blocks well-formed for later phases.
* Expression-bodied block parsing now mirrors the statement-block safeguards: it enforces loop progress, exits cleanly at end-of-file, and synthesizes a missing `}` with a diagnostic so malformed lambda bodies or block expressions cannot spin forever.
* Parenthesized, tuple, and collection constructs now emit missing-delimiter diagnostics when recovery inserts placeholder `)` or `]` tokens so the tree remains well-formed and the user sees an actionable error at the gap.
* Statement terminator recovery now treats blank lines as implicit boundaries and bails out of expressions at newlines, inserting a semicolon diagnostic so blocks advance even when delimiters are omitted across lines.
* Recovery retains skipped-token spans for internal diagnostics without surfacing them in user-facing error lists so the parser can recover quietly while developers can still opt into extra tracing when needed.
* Added parser tests that ensure skipped-token diagnostics are suppressed by default for both top-level recovery and type-member recovery sequences.
* Loop progress tracking now snapshots the initial token position before enforcing forward motion and statement terminator recovery recognizes trailing newlines or member-start tokens as implicit boundaries without surfacing missing-semicolon diagnostics, preventing stall guards from firing on valid end-of-file parses.
* Statement terminators now emit a `SemicolonExpected` diagnostic when a new statement begins on the same line without a delimiter, preventing multi-statement lines from silently compiling; a parser regression test covers the scenario. Same-line recovery inside blocks now reports the missing semicolon without discarding the following statement so both statements are preserved for later phases.
* Progress guards now treat end-of-file as a valid exit condition and avoid forcing advancement past the final token. Invalid multi-statement samples with unterminated expressions now produce trees populated with missing tokens/nodes instead of tripping stall diagnostics, and a regression test locks in the behavior.
* Added explicit end-of-file escape hatches to tuple/collection/parameter/type-argument loops so loop-progress tracking exits cleanly when required delimiters are missing, preventing stalls on incomplete syntax.
* Running `dotnet run --property WarningLevel=0 --project ../Raven.Compiler/Raven.Compiler.csproj -p:UseRavenCoreReference=false -- --emit-core-types-only --output-type classlib -o Raven.Core.dll` from `src/Raven.Core` now completes, even though the solution-wide build still reports the Raven.Core invoke as failing.
* Running `samples/build.sh` with the regenerated Raven.Core still fails: `arrays.rav` now aborts on a parser cancellation token trip, and subsequent samples crash with `BadImageFormatException` while loading the freshly emitted core library, so no sample DLLs are produced.【F:sample_run.log†L1-L200】
