# Generic Math Constraint Investigation

## Goal
Document the current failure when compiling the `generic-math-error.rav` and `tokenizer.rav` samples and outline hypotheses around the recursive substitution path triggered by `INumber<TSelf>` constraints.

## Reproduction
1. Run the compiler against the samples:
   ```bash
   dotnet run --project src/Raven.Compiler -- samples/generic-math-error.rav
   dotnet run --project src/Raven.Compiler -- samples/tokenizer.rav
   ```
2. Both runs terminate with an exception rather than producing diagnostics or an output binary.
3. Latest local attempt after re-running generators stalled while building `Raven.Core` (the `dotnet run` invocation inside `Raven.Core.csproj`), requiring cancellation and leaving the debug logs unchanged.
   - The `CompileRavenCore` target shells out to `dotnet run --project ../Raven.Compiler/Raven.Compiler.csproj` with `--emit-core-types-only` against `Option.rav` and `Result.rav`, so any hang in `ravc` during that step blocks sample reproduction.【F:src/Raven.Core/Raven.Core.csproj†L15-L33】
   - Manually invoking the same `ravc` command (`dotnet run --project src/Raven.Compiler -- --emit-core-types-only ... Option.rav Result.rav`) also stalled and required cancellation, confirming the reproduction is blocked before the sample-specific compilation begins.
   - Running the requested variant (`dotnet run --project ../src/Raven.Compiler --property WarningLevel=0 -- ./tokenizer.rav -o test.dll -d pretty --run`) also stalled during the same `Raven.Core` build step and had to be canceled, so it did not reach tokenizer-specific diagnostics.
4. After completing a full solution build, the tokenizer command produced pretty-printed output but failed when creating the app host with `DOTNET_ROOT` missing (`Raven.Compiler.AppHostBuilder`). The debug artifacts were updated to `IQueryable -> IQueryable` and `Option<T> -> ulong` during this run, so the recursion no longer surfaced before the host failure.【F:samples/ConstructedNamedTypeSymbol.debug.txt†L1-L1】【F:samples/Compilation.debug.txt†L1-L1】

## Findings
- The stack trace for both samples shows repeated recursion in `ConstructedNamedTypeSymbol.Substitute`, triggered while iterating `argNamed.AllInterfaces` during extension receiver unification. That path starts in `Compilation.TryUnifyExtensionReceiver` and calls `argNamed.AllInterfaces`, which in turn calls `ConstructedNamedTypeSymbol.AllInterfaces` and substitutes every interface reference.【F:src/Raven.CodeAnalysis/Compilation.Conversions.cs†L542-L640】【F:src/Raven.CodeAnalysis/Symbols/Constructed/ConstructedNamedTypeSymbol.cs†L331-L337】
- `ConstructedNamedTypeSymbol.NormalizeTypeArguments` substitutes every explicit type argument before storing them, even when the argument is already concrete. The method does not guard against re-entrance or repeated normalization of the same argument set, so re-constructing a generic type re-triggers substitution immediately.【F:src/Raven.CodeAnalysis/Symbols/Constructed/ConstructedNamedTypeSymbol.cs†L205-L232】
- `Substitute` rebuilds generic named types by invoking `Construct` whenever any argument changes, which immediately triggers `NormalizeTypeArguments` for the new `ConstructedNamedTypeSymbol`. With self-referential constraints like `INumber<TSelf>`, this loop can re-enter substitution on the same `(type parameter, argument)` pair indefinitely because there is no memoization or visited tracking.【F:src/Raven.CodeAnalysis/Symbols/Constructed/ConstructedNamedTypeSymbol.cs†L43-L103】【F:src/Raven.CodeAnalysis/Symbols/Constructed/ConstructedNamedTypeSymbol.cs†L131-L189】
- `SubstituteNamedType` also eagerly constructs nested generic types when substitutions are available, again without a guard to short-circuit previously substituted parameter/argument pairs. This expands the recursion surface when constraints or interface closures contain other generic references.【F:src/Raven.CodeAnalysis/Symbols/Constructed/ConstructedNamedTypeSymbol.cs†L234-L284】
- The `.debug.txt` logs from the `tokenizer.rav` run show repeated substitution of the same constructed type/interface chain before the exception is thrown. The last recorded entries include `DEBUG: (ConstructedNamedTypeSymbol.Substitute). Constructed type: ReadOnlyMemory; Substituted type: T` and `DEBUG (Compilation.TryUnifyExtensionReceiver). Param type: Option<T>; Argument type: ReadOnlyMemory<char>`, which corroborates the recursive call chain in the stack trace.【F:src/Raven.CodeAnalysis/Symbols/Constructed/ConstructedNamedTypeSymbol.cs†L109-L189】【F:src/Raven.CodeAnalysis/Compilation.Conversions.cs†L542-L620】
- `ConstructedNamedTypeSymbol.Substitute` now records re-entrant substitutions to `ConstructedNamedTypeSymbol.substitution.trace.txt` using a per-call depth counter and seen-set of `(parameter, argument)` pairs, and it memoizes substitutions plus short-circuits repeated generic named-type visits to avoid re-entering the same constructed interface chain.【F:src/Raven.CodeAnalysis/Symbols/Constructed/ConstructedNamedTypeSymbol.cs†L105-L230】
- Constructed named types are now canonicalized through a shared cache keyed by the reference identity of the original definition, type arguments, containing type override, and inherited substitution dictionary. This avoids recursive equality checks inside the cache comparer while still stabilizing identity for repeated constructions within the same symbol graph.【F:src/Raven.CodeAnalysis/Symbols/Constructed/ConstructedNamedTypeSymbol.cs†L18-L92】
- During sample compilation runs, `Raven.Compiler.AppHostBuilder` can throw when `DOTNET_ROOT` is missing, which blocks `ravc` from producing output binaries even after successful compilation. Set `DOTNET_ROOT` or `RAVEN_DOTNET_ROOT` in the environment to validate output generation for sample runs.【F:src/Raven.Compiler/AppHostBuilder.cs†L25-L144】
- Running `samples/test-result3.rav` with `DOTNET_ROOT` set now progresses into emission, but fails with `ArgumentNullException` in `ExpressionGenerator.EmitAssignmentExpression` (null FieldInfo) during `Program.Main`. Debug artifacts now show `Result -> Int32` substitution and extension receiver inference `Option<T> -> ulong`, so the constructed-type cache no longer triggers the previous recursion path for this sample.【F:src/Raven.CodeAnalysis/CodeGen/Generators/ExpressionGenerator.cs†L2180-L2200】【F:samples/ConstructedNamedTypeSymbol.debug.txt†L1-L1】【F:samples/Compilation.debug.txt†L1-L1】
- `SourceNamedTypeSymbol.ComputeAllInterfaces` guards against interface cycles for the original definition via a `seen` set, but `ConstructedNamedTypeSymbol.AllInterfaces` substitutes each original interface without a comparable guard. If substitution reconstructs an interface that re-enters the same original AllInterfaces chain, it can trigger repeated substitution even though the source type’s interface graph is acyclic.【F:src/Raven.CodeAnalysis/Symbols/Source/SourceNamedTypeSymbol.cs†L200-L238】【F:src/Raven.CodeAnalysis/Symbols/Constructed/ConstructedNamedTypeSymbol.cs†L331-L337】
- The repository-local debug artifacts in `samples/ConstructedNamedTypeSymbol.debug.txt` and `samples/Compilation.debug.txt` reflect the most recent run to touch them (currently `IQueryable -> IQueryable` and `Option<T> -> ulong`), so a targeted reproduction should capture per-sample logs before they are overwritten.【F:samples/ConstructedNamedTypeSymbol.debug.txt†L1-L1】【F:samples/Compilation.debug.txt†L1-L1】
- Both `SourceTypeParameterSymbol` and `PETypeParameterSymbol` expand constraint interfaces by iterating each constraint’s `interfaceSymbol.AllInterfaces`. If a constraint is a constructed interface, that call flows back into `ConstructedNamedTypeSymbol.AllInterfaces`, so type-parameter constraints can re-trigger substitution even when the original interface graph is acyclic.【F:src/Raven.CodeAnalysis/Symbols/Source/SourceTypeParameterSymbol.cs†L63-L124】【F:src/Raven.CodeAnalysis/Symbols/PE/PETypeParameterSymbol.cs†L110-L178】【F:src/Raven.CodeAnalysis/Symbols/Constructed/ConstructedNamedTypeSymbol.cs†L331-L337】
- `ConstructedNamedTypeSymbol.AllInterfaces` derives its interface list from the original definition and substitutes each interface on demand, but there is no shared canonical cache across constructed instances. Combined with `SymbolEqualityComparer` only normalizing aliases (not constructed/original pairs), this means identity can diverge even when two constructed symbols are logically equal, so any reference-based caches or lookups can see duplicates and re-entry unless we canonicalize constructed interfaces or centralize the cache.【F:src/Raven.CodeAnalysis/Symbols/Constructed/ConstructedNamedTypeSymbol.cs†L418-L430】【F:src/Raven.CodeAnalysis/SymbolEqualityComparer.cs†L430-L458】

## Next Steps
- [x] Add lightweight instrumentation (e.g., a recursion depth counter and an `ImmutableHashSet` of `(parameter, argument)` pairs) around `NormalizeTypeArguments`/`Substitute` to capture the exact loop triggered by `INumber<TSelf>`.
- [x] Introduce a recursion guard or memoization cache inside `Substitute` (and the equality path that calls it) so re-visiting the same substitution returns the existing symbol instead of reconstructing it.
- [x] Implement a shared cache to canonicalize constructed named types used during interface expansion.
- [ ] Add a regression sample or unit test that exercises extension receiver inference against `INumber<T>` to confirm the hang/exception is resolved once substitution short-circuits.
- [x] Add a test that asserts constructed metadata types are canonicalized for identical type arguments.
