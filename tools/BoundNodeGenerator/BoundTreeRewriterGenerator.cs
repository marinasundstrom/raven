using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace BoundNodeGenerator;

static class BoundTreeRewriterGenerator
{
    private static readonly HashSet<string> SkipRewriterMethods = new(StringComparer.Ordinal)
    {
        "AssignmentExpression",
        "BreakStatement",
        "ContinueStatement",
    };

    private static bool IsDerivedFrom(
        BoundNodeModel node,
        string rootTypeName,
        IReadOnlyDictionary<string, BoundNodeModel> byName)
    {
        if (node.Name == rootTypeName)
            return true;

        var currentBase = node.BaseTypeName;
        while (!string.IsNullOrEmpty(currentBase))
        {
            if (string.Equals(currentBase, rootTypeName, StringComparison.Ordinal))
                return true;

            if (!byName.TryGetValue(currentBase!, out var baseModel))
                break;

            currentBase = baseModel.BaseTypeName;
        }

        return false;
    }

    public static string Generate(IEnumerable<BoundNodeModel> nodes)
    {
        var allNodes = nodes.ToList();
        var byName = allNodes.ToDictionary(n => n.Name, StringComparer.Ordinal);
        var concreteNodes = allNodes.Where(static n => !n.IsAbstract)
            .OrderBy(n => n.Name, StringComparer.Ordinal)
            .ToList();

        var builder = new StringBuilder();
        builder.AppendLine("// <auto-generated />");
        builder.AppendLine("#nullable enable");
        builder.AppendLine();

        var requiresImmutableArray = concreteNodes.Any(RequiresImmutableArrayHelper);

        if (requiresImmutableArray)
        {
            builder.AppendLine("using System.Collections.Immutable;");
            builder.AppendLine();
        }

        builder.AppendLine("namespace Raven.CodeAnalysis;");
        builder.AppendLine();
        builder.AppendLine("partial class BoundTreeRewriter");
        builder.AppendLine("{");

        var statementNodes = concreteNodes.Where(n => IsDerivedFrom(n, "BoundStatement", byName)).OrderBy(n => n.Name, StringComparer.Ordinal).ToList();
        var expressionNodes = concreteNodes
            .Where(n =>
                IsDerivedFrom(n, "BoundExpression", byName) &&
                !IsDerivedFrom(n, "BoundPattern", byName) &&
                !IsDerivedFrom(n, "BoundDesignator", byName))
            .OrderBy(n => n.Name, StringComparer.Ordinal)
            .ToList();
        var patternNodes = concreteNodes.Where(n => IsDerivedFrom(n, "BoundPattern", byName)).OrderBy(n => n.Name, StringComparer.Ordinal).ToList();
        var designatorNodes = concreteNodes.Where(n => IsDerivedFrom(n, "BoundDesignator", byName)).OrderBy(n => n.Name, StringComparer.Ordinal).ToList();

        builder.AppendLine("    public virtual BoundStatement VisitStatement(BoundStatement statement)");
        builder.AppendLine("    {");
        builder.AppendLine("        return statement switch");
        builder.AppendLine("        {");
        foreach (var node in statementNodes)
            builder.AppendLine($"            {node.Name} n => (BoundStatement)Visit{node.VisitorMethodName}(n)!,");
        builder.AppendLine("            _ => statement,");
        builder.AppendLine("        };");
        builder.AppendLine("    }");
        builder.AppendLine();

        builder.AppendLine("    public virtual BoundExpression? VisitExpression(BoundExpression? node)");
        builder.AppendLine("    {");
        builder.AppendLine("        if (node is null)");
        builder.AppendLine("            return null;");
        builder.AppendLine();
        builder.AppendLine("        return node switch");
        builder.AppendLine("        {");
        builder.AppendLine("            BoundPattern p => (BoundExpression?)VisitPattern(p),");
        builder.AppendLine("            BoundDesignator d => (BoundExpression?)VisitDesignator(d),");
        foreach (var node in expressionNodes)
            builder.AppendLine($"            {node.Name} n => (BoundExpression?)Visit{node.VisitorMethodName}(n),");
        builder.AppendLine("            _ => node,");
        builder.AppendLine("        };");
        builder.AppendLine("    }");
        builder.AppendLine();

        builder.AppendLine("    public virtual BoundNode VisitPattern(BoundPattern pattern)");
        builder.AppendLine("    {");
        builder.AppendLine("        return pattern switch");
        builder.AppendLine("        {");
        foreach (var node in patternNodes)
            builder.AppendLine($"            {node.Name} n => Visit{node.VisitorMethodName}(n) ?? n,");
        builder.AppendLine("            _ => pattern,");
        builder.AppendLine("        };");
        builder.AppendLine("    }");
        builder.AppendLine();

        builder.AppendLine("    public virtual BoundNode VisitDesignator(BoundDesignator designator)");
        builder.AppendLine("    {");
        builder.AppendLine("        return designator switch");
        builder.AppendLine("        {");
        foreach (var node in designatorNodes)
            builder.AppendLine($"            {node.Name} n => Visit{node.VisitorMethodName}(n) ?? n,");
        builder.AppendLine("            _ => designator,");
        builder.AppendLine("        };");
        builder.AppendLine("    }");
        builder.AppendLine();

        foreach (var node in concreteNodes)
        {
            if (!node.HasUpdate)
                continue;

            if (SkipRewriterMethods.Contains(node.VisitorMethodName))
                continue;

            builder.AppendLine($"    public override BoundNode? Visit{node.VisitorMethodName}({node.Name} node)");
            builder.AppendLine("    {");

            var statements = new List<string>();
            var arguments = new List<string>();

            foreach (var parameter in node.Parameters)
            {
                var propertyAccess = $"node.{parameter.PropertyName}";

                switch (parameter.Kind)
                {
                    case ParameterKind.BoundNode:
                    {
                        var visitCall = $"Visit({propertyAccess})" + (parameter.IsNullable ? string.Empty : "!");
                        var assignment = $"({parameter.TypeName}){visitCall}";
                        statements.Add($"        var {parameter.ParameterName} = {assignment};");
                        arguments.Add(parameter.ParameterName);
                        break;
                    }

                    case ParameterKind.BoundNodeList:
                    {
                        var visitListCall = $"VisitList({propertyAccess})";
                        if (parameter.TypeName.StartsWith("ImmutableArray<", StringComparison.Ordinal))
                        {
                            visitListCall += ".ToImmutableArray()";
                        }

                        statements.Add($"        var {parameter.ParameterName} = {visitListCall};");
                        arguments.Add(parameter.ParameterName);
                        break;
                    }

                    case ParameterKind.Symbol:
                    {
                        var visitCall = $"VisitSymbol({propertyAccess})" + (parameter.IsNullable ? string.Empty : "!");
                        var assignment = $"({parameter.TypeName}){visitCall}";
                        statements.Add($"        var {parameter.ParameterName} = {assignment};");
                        arguments.Add(parameter.ParameterName);
                        break;
                    }

                    case ParameterKind.SymbolList:
                    {
                        var typeArgument = parameter.ElementTypeName ?? "ISymbol";
                        var visitCall = $"VisitSymbolList<{typeArgument}>({propertyAccess})";
                        statements.Add($"        var {parameter.ParameterName} = {visitCall};");
                        arguments.Add(parameter.ParameterName);
                        break;
                    }

                    default:
                        arguments.Add(propertyAccess);
                        break;
                }
            }

            foreach (var statement in statements)
                builder.AppendLine(statement);

            if (statements.Count > 0)
                builder.AppendLine();

            builder.AppendLine($"        return node.Update({string.Join(", ", arguments)});");
            builder.AppendLine("    }");
            builder.AppendLine();
        }

        builder.AppendLine("}");
        return builder.ToString();
    }

    private static bool RequiresImmutableArrayHelper(BoundNodeModel model)
    {
        if (!model.HasUpdate)
            return false;

        if (SkipRewriterMethods.Contains(model.VisitorMethodName))
            return false;

        return model.Parameters.Any(static p =>
            p.Kind == ParameterKind.BoundNodeList && p.TypeName.StartsWith("ImmutableArray<", StringComparison.Ordinal));
    }
}
